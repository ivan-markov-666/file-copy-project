docker-compose.override.yml
# Override за локална разработка
services:
  db:
    restart: unless-stopped
    volumes:
      - ./db/logs:/var/log/postgresql
    command: ['postgres', '-c', 'log_statement=all', '-c', 'log_connections=on', '-c', 'log_disconnections=on']

  redis:
    restart: unless-stopped
    volumes:
      - ./redis/logs:/data/logs

  auth-service:
    restart: unless-stopped
    environment:
      DEBUG: 'true'
      LOG_LEVEL: 'debug'
    volumes:
      - ./services/auth:/app
      - /app/node_modules
      - ./services/auth/logs:/app/logs

  user-service:
    restart: unless-stopped
    environment:
      DEBUG: 'true'
      LOG_LEVEL: 'debug'
    volumes:
      - ./services/user:/app
      - /app/node_modules
      - ./services/user/logs:/app/logs

  course-service:
    restart: unless-stopped
    environment:
      DEBUG: 'true'
      LOG_LEVEL: 'debug'
    volumes:
      - ./services/course:/app
      - /app/node_modules
      - ./services/course/logs:/app/logs

  test-service:
    restart: unless-stopped
    environment:
      DEBUG: 'true'
      LOG_LEVEL: 'debug'
    volumes:
      - ./services/test:/app
      - /app/node_modules
      - ./services/test/logs:/app/logs

  analytics-service:
    restart: unless-stopped
    environment:
      DEBUG: 'true'
      LOG_LEVEL: 'debug'
    volumes:
      - ./services/analytics:/app
      - /app/node_modules
      - ./services/analytics/logs:/app/logs

  ads-service:
    restart: unless-stopped
    environment:
      DEBUG: 'true'
      LOG_LEVEL: 'debug'
    volumes:
      - ./services/ads:/app
      - /app/node_modules
      - ./services/ads/logs:/app/logs

  frontend:
    restart: unless-stopped
    environment:
      NODE_ENV: development
      CHOKIDAR_USEPOLLING: 'true'
      REACT_APP_API_URL: http://localhost:8080
    volumes:
      - ./frontend:/app
      - /app/node_modules

  nginx:
    restart: unless-stopped
    volumes:
      - ./nginx/logs:/var/log/nginx


.env.example
### Съдържание на .env файл ###


### Край на .env файл ###

.gitignore
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
pnpm-debug.log*

# Diagnostic reports
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage
.grunt

# Bower dependency directory
bower_components

# Node.js dependency directories
node_modules/
jspm_packages/

# TypeScript compiled files
dist/
build/

# Snowpack dependency directory
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
# .env
# .env.development.local
# .env.test.local
# .env.production.local
# .env.local

# parcel-bundler cache
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

# Docker volumes
postgres_data/
redis_data/

# IDE
.idea
.vscode/*
!.vscode/extensions.json
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json

# OS specific files
.DS_Store
Thumbs.db

# Database
*.sqlite
*.sqlite3

# Temporary files
*.tmp
*.temp

# Debug files
debug.log
*.debug

# Backup files
*.bak
*.backup

# Binary files for plugins
*.exe
*.dll
*.so
*.dylib


services
services/auth
services/auth/Dockerfile
# services/auth/Dockerfile
FROM node:20-alpine AS development

WORKDIR /usr/src/app

COPY package*.json ./

RUN npm install

COPY . .

RUN npm run build

FROM node:20-alpine AS production

ARG NODE_ENV=production
ENV NODE_ENV=${NODE_ENV}

WORKDIR /usr/src/app

COPY package*.json ./

RUN npm install --only=production

COPY --from=development /usr/src/app/dist ./dist
COPY --from=development /usr/src/app/node_modules ./node_modules

CMD ["node", "dist/main"]

services/auth/src
services/auth/src/app.controller.ts
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}


services/auth/src/app.module.ts
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { AuthModule } from './auth/auth.module';
import { PasswordReset } from './auth/entities/password-reset.entity';
import { Session } from './auth/entities/session.entity';
import appConfig from './config/app.config';
import { User } from './users/entities/user.entity';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      load: [appConfig],
    }),
    TypeOrmModule.forRootAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: (configService: ConfigService) => ({
        type: 'postgres',
        host: configService.get('database.host'),
        port: configService.get('database.port'),
        username: configService.get('database.username'),
        password: configService.get('database.password'),
        database: configService.get('database.database'),
        entities: [User, PasswordReset, Session],
        synchronize: configService.get('NODE_ENV') === 'development',
        logging: configService.get('NODE_ENV') === 'development',
      }),
    }),
    AuthModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}


services/auth/src/app.service.ts
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}


services/auth/src/main.ts
import { ValidationPipe } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalPipes(new ValidationPipe());
  await app.listen(process.env.PORT || 3000);
}
bootstrap().catch((err) => {
  console.error('Error starting server:', err);
  process.exit(1);
});


services/auth/src/app.controller.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});


services/auth/src/config
services/auth/src/config/app.config.ts
export default () => ({
  port: parseInt(process.env.PORT || '3001', 10),
  database: {
    host: process.env.DATABASE_HOST || 'localhost',
    port: parseInt(process.env.DATABASE_PORT || '5433', 10),
    username: process.env.DATABASE_USERNAME || 'postgres',
    password: process.env.DATABASE_PASSWORD || 'postgres',
    database: process.env.DATABASE_NAME || 'learning_platform',
  },
  jwt: {
    secret: process.env.JWT_SECRET || 'testSecretKey',
    expiresIn: process.env.JWT_EXPIRES_IN || '1h',
    refreshExpiresIn: process.env.JWT_REFRESH_EXPIRES_IN || '7d',
  },
  redis: {
    host: process.env.REDIS_HOST || 'localhost',
    port: parseInt(process.env.REDIS_PORT || '6379', 10),
    password: process.env.REDIS_PASSWORD || 'redis_password',
  },
});


services/auth/src/common
services/auth/src/common/entities
services/auth/src/common/entities/base.entity.ts
import {
  CreateDateColumn,
  PrimaryGeneratedColumn,
  UpdateDateColumn,
} from 'typeorm';

export abstract class BaseEntity {
  @PrimaryGeneratedColumn()
  id: number;

  @CreateDateColumn({ name: 'created_at' })
  createdAt: Date;

  @UpdateDateColumn({ name: 'updated_at' })
  updatedAt: Date;
}


services/auth/src/users
services/auth/src/users/entities
services/auth/src/users/entities/user.entity.ts
import { Column, Entity, Index, OneToMany } from 'typeorm';
import { PasswordReset } from '../../auth/entities/password-reset.entity';
import { Session } from '../../auth/entities/session.entity';
import { BaseEntity } from '../../common/entities/base.entity';

@Entity('users')
export class User extends BaseEntity {
  @Column({ length: 255, unique: true })
  @Index('idx_user_email')
  email: string;

  @Column({ name: 'password_hash', length: 255 })
  passwordHash: string;

  @Column({ length: 255 })
  salt: string;

  @Column({ length: 50, default: 'user' })
  role: string;

  @Column({ name: 'is_active', default: true })
  isActive: boolean;

  @Column({ name: 'failed_login_attempts', default: 0 })
  failedLoginAttempts: number;

  @Column({ name: 'last_login', nullable: true, type: 'timestamp' })
  lastLogin: Date | null;

  @OneToMany(() => PasswordReset, (passwordReset) => passwordReset.user)
  passwordResets: PasswordReset[];

  @OneToMany(() => Session, (session) => session.user)
  sessions: Session[];
}


services/auth/src/auth
services/auth/src/auth/auth.controller.ts
import {
  Body,
  Controller,
  Get,
  HttpCode,
  HttpStatus,
  Post,
  Request,
  UseGuards,
} from '@nestjs/common';
import { AuthService } from './auth.service';
import { LoginDto } from './dto/login.dto';
import { RegisterDto } from './dto/register.dto';
import { ResetPasswordRequestDto } from './dto/reset-password-request.dto';
import { ResetPasswordDto } from './dto/reset-password.dto';
import { JwtAuthGuard } from './guards/jwt-auth.guard';

// Дефиниция на интерфейс за Request с типизация
interface RequestWithUser {
  user: {
    id: number;
    email: string;
    role: string;
  };
  headers: {
    authorization?: string;
  };
}

@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Post('register')
  async register(@Body() registerDto: RegisterDto) {
    const { user, token } = await this.authService.register(registerDto);
    return {
      id: user.id,
      email: user.email,
      role: user.role,
      accessToken: token,
    };
  }

  @Post('login')
  @HttpCode(HttpStatus.OK)
  async login(@Body() loginDto: LoginDto) {
    const { user, token } = await this.authService.login(loginDto);
    return {
      id: user.id,
      email: user.email,
      role: user.role,
      accessToken: token,
    };
  }

  @Post('reset-password-request')
  @HttpCode(HttpStatus.OK)
  async resetPasswordRequest(
    @Body() resetPasswordRequestDto: ResetPasswordRequestDto,
  ) {
    await this.authService.resetPasswordRequest(resetPasswordRequestDto);
    return {
      message:
        'Ако имейлът съществува, ще получите линк за рестартиране на паролата.',
    };
  }

  @Post('reset-password')
  @HttpCode(HttpStatus.OK)
  async resetPassword(@Body() resetPasswordDto: ResetPasswordDto) {
    await this.authService.resetPassword(resetPasswordDto);
    return {
      message: 'Паролата беше успешно променена.',
    };
  }

  @UseGuards(JwtAuthGuard)
  @Post('logout')
  @HttpCode(HttpStatus.OK)
  async logout(@Request() req: RequestWithUser) {
    const token = req.headers.authorization?.split(' ')[1] || '';
    await this.authService.logout(token);
    return {
      message: 'Успешно излизане от системата.',
    };
  }

  @UseGuards(JwtAuthGuard)
  @Get('profile')
  getProfile(@Request() req: RequestWithUser) {
    const user = req.user;
    return {
      id: user.id,
      email: user.email,
      role: user.role,
    };
  }
}


services/auth/src/auth/auth.service.spec.ts
// services/auth/src/auth/auth.service.spec.ts
import { BadRequestException, UnauthorizedException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { JwtService } from '@nestjs/jwt';
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import * as bcrypt from 'bcrypt';
import { Repository } from 'typeorm';
import { User } from '../users/entities/user.entity';
import { AuthService } from './auth.service';
import { PasswordReset } from './entities/password-reset.entity';
import { Session } from './entities/session.entity';

// Mock bcrypt
jest.mock('bcrypt', () => ({
  genSalt: jest.fn().mockResolvedValue('mockedSalt'),
  hash: jest.fn().mockResolvedValue('hashedPassword'),
  compare: jest.fn(),
}));

describe('AuthService', () => {
  let service: AuthService;
  let userRepository: Repository<User>;
  // Дефинирай тези променливи но ги не маркирай с eslint no-unused-vars
  /* eslint-disable @typescript-eslint/no-unused-vars */
  let passwordResetRepository: Repository<PasswordReset>;
  let sessionRepository: Repository<Session>;
  /* eslint-enable @typescript-eslint/no-unused-vars */
  let jwtService: JwtService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AuthService,
        {
          provide: getRepositoryToken(User),
          useValue: {
            findOne: jest.fn(),
            create: jest.fn(),
            save: jest.fn(),
          },
        },
        {
          provide: getRepositoryToken(PasswordReset),
          useValue: {
            findOne: jest.fn(),
            create: jest.fn(),
            save: jest.fn(),
          },
        },
        {
          provide: getRepositoryToken(Session),
          useValue: {
            delete: jest.fn(),
          },
        },
        {
          provide: JwtService,
          useValue: {
            sign: jest.fn(() => 'jwt-token'),
            verify: jest.fn(),
          },
        },
        {
          provide: ConfigService,
          useValue: {
            get: jest.fn(),
          },
        },
      ],
    }).compile();

    service = module.get<AuthService>(AuthService);
    userRepository = module.get<Repository<User>>(getRepositoryToken(User));
    passwordResetRepository = module.get<Repository<PasswordReset>>(
      getRepositoryToken(PasswordReset),
    );
    sessionRepository = module.get<Repository<Session>>(
      getRepositoryToken(Session),
    );
    jwtService = module.get<JwtService>(JwtService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('register', () => {
    it('should register a new user successfully', async () => {
      // Arrange
      const registerDto = {
        email: 'test@example.com',
        password: 'StrongP@ss1',
      };

      jest
        .spyOn(userRepository, 'findOne')
        .mockImplementation(() => Promise.resolve(null));

      jest.spyOn(userRepository, 'create').mockImplementation(
        () =>
          ({
            id: 1,
            email: registerDto.email,
            passwordHash: 'hashedPassword',
            salt: 'mockedSalt',
            role: 'user',
            isActive: true,
            failedLoginAttempts: 0,
            lastLogin: null,
          }) as User,
      );

      jest
        .spyOn(userRepository, 'save')
        .mockImplementation((user) => Promise.resolve(user as User));

      jest.spyOn(jwtService, 'sign').mockImplementation(() => 'jwt-token');

      // Act
      const result = await service.register(registerDto);

      // Assert
      expect(result).toHaveProperty('user');
      expect(result).toHaveProperty('token');
      expect(result.user.email).toBe(registerDto.email);
      expect(result.token).toBe('jwt-token');
      expect(bcrypt.genSalt).toHaveBeenCalled();
      expect(bcrypt.hash).toHaveBeenCalledWith(
        registerDto.password,
        'mockedSalt',
      );
      expect(userRepository.save).toHaveBeenCalled();
      expect(jwtService.sign).toHaveBeenCalled();
    });

    it('should throw BadRequestException if user already exists', async () => {
      // Arrange
      const registerDto = {
        email: 'existing@example.com',
        password: 'StrongP@ss1',
      };

      jest.spyOn(userRepository, 'findOne').mockImplementation(() =>
        Promise.resolve({
          id: 1,
          email: registerDto.email,
        } as User),
      );

      // Act & Assert
      await expect(async () => {
        await service.register(registerDto);
      }).rejects.toThrow(BadRequestException);

      expect(userRepository.findOne).toHaveBeenCalledWith({
        where: { email: registerDto.email },
      });
    });
  });

  describe('login', () => {
    it('should login successfully and return token', async () => {
      // Arrange
      const loginDto = {
        email: 'test@example.com',
        password: 'StrongP@ss1',
      };

      const user = {
        id: 1,
        email: loginDto.email,
        passwordHash: 'hashedPassword',
        salt: 'mockedSalt',
        role: 'user',
        isActive: true,
        failedLoginAttempts: 0,
        lastLogin: null,
      } as User;

      jest
        .spyOn(userRepository, 'findOne')
        .mockImplementation(() => Promise.resolve(user));

      jest
        .spyOn(bcrypt, 'compare')
        .mockImplementation(() => Promise.resolve(true));

      jest.spyOn(userRepository, 'save').mockImplementation((updatedUser) =>
        Promise.resolve({
          ...user,
          ...updatedUser,
          failedLoginAttempts: 0,
          lastLogin: expect.any(Date),
        } as User),
      );

      jest.spyOn(jwtService, 'sign').mockImplementation(() => 'jwt-token');

      // Act
      const result = await service.login(loginDto);

      // Assert
      expect(result).toHaveProperty('user');
      expect(result).toHaveProperty('token');
      expect(result.user.email).toBe(loginDto.email);
      expect(result.token).toBe('jwt-token');
      expect(userRepository.save).toHaveBeenCalled();
      expect(jwtService.sign).toHaveBeenCalled();
    });

    it('should throw UnauthorizedException if user not found', async () => {
      // Arrange
      const loginDto = {
        email: 'nonexistent@example.com',
        password: 'StrongP@ss1',
      };

      jest
        .spyOn(userRepository, 'findOne')
        .mockImplementation(() => Promise.resolve(null));

      // Act & Assert
      await expect(async () => {
        await service.login(loginDto);
      }).rejects.toThrow(UnauthorizedException);
    });

    it('should throw UnauthorizedException if account is not active', async () => {
      // Arrange
      const loginDto = {
        email: 'inactive@example.com',
        password: 'StrongP@ss1',
      };

      jest.spyOn(userRepository, 'findOne').mockImplementation(() =>
        Promise.resolve({
          id: 1,
          email: loginDto.email,
          passwordHash: 'hashedPassword',
          salt: 'mockedSalt',
          role: 'user',
          isActive: false,
          failedLoginAttempts: 0,
          lastLogin: null,
        } as User),
      );

      // Act & Assert
      await expect(async () => {
        await service.login(loginDto);
      }).rejects.toThrow(UnauthorizedException);
    });

    it('should throw UnauthorizedException if password is invalid', async () => {
      // Arrange
      const loginDto = {
        email: 'test@example.com',
        password: 'WrongP@ss1',
      };

      const user = {
        id: 1,
        email: loginDto.email,
        passwordHash: 'hashedPassword',
        salt: 'mockedSalt',
        role: 'user',
        isActive: true,
        failedLoginAttempts: 0,
        lastLogin: null,
      } as User;

      jest
        .spyOn(userRepository, 'findOne')
        .mockImplementation(() => Promise.resolve(user));

      jest
        .spyOn(bcrypt, 'compare')
        .mockImplementation(() => Promise.resolve(false));

      jest.spyOn(userRepository, 'save').mockImplementation((updatedUser) =>
        Promise.resolve({
          ...user,
          ...updatedUser,
          failedLoginAttempts: 1,
        } as User),
      );

      // Act & Assert
      await expect(async () => {
        await service.login(loginDto);
      }).rejects.toThrow(UnauthorizedException);

      expect(userRepository.save).toHaveBeenCalledWith(
        expect.objectContaining({
          failedLoginAttempts: 1,
        }),
      );
    });

    it('should lock account after 5 failed login attempts', async () => {
      // Arrange
      const loginDto = {
        email: 'test@example.com',
        password: 'WrongP@ss1',
      };

      const user = {
        id: 1,
        email: loginDto.email,
        passwordHash: 'hashedPassword',
        salt: 'mockedSalt',
        role: 'user',
        isActive: true,
        failedLoginAttempts: 4,
        lastLogin: null,
      } as User;

      jest
        .spyOn(userRepository, 'findOne')
        .mockImplementation(() => Promise.resolve(user));

      jest
        .spyOn(bcrypt, 'compare')
        .mockImplementation(() => Promise.resolve(false));

      jest.spyOn(userRepository, 'save').mockImplementation((updatedUser) =>
        Promise.resolve({
          ...user,
          ...updatedUser,
          failedLoginAttempts: 5,
          isActive: false,
        } as User),
      );

      // Act & Assert
      await expect(async () => {
        await service.login(loginDto);
      }).rejects.toThrow(UnauthorizedException);

      expect(userRepository.save).toHaveBeenCalledWith(
        expect.objectContaining({
          failedLoginAttempts: 5,
          isActive: false,
        }),
      );
    });
  });

  // Можете да добавите още тестове за останалите методи
});


services/auth/src/auth/auth.module.ts
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from '../users/entities/user.entity';
import { AuthController } from './auth.controller';
import { AuthService } from './auth.service';
import { PasswordReset } from './entities/password-reset.entity';
import { Session } from './entities/session.entity';
import { JwtStrategy } from './strategies/jwt.strategy';

@Module({
  imports: [
    PassportModule.register({ defaultStrategy: 'jwt' }),
    JwtModule.registerAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: (configService: ConfigService) => {
        const secret = configService.get<string>('jwt.secret');
        if (!secret) {
          throw new Error('JWT secret is not defined');
        }
        return {
          secret,
          signOptions: {
            expiresIn: configService.get('jwt.expiresIn', '1h'),
          },
        };
      },
    }),
    TypeOrmModule.forFeature([User, PasswordReset, Session]),
  ],
  controllers: [AuthController],
  providers: [AuthService, JwtStrategy],
  exports: [AuthService, JwtStrategy],
})
export class AuthModule {}


services/auth/src/auth/auth.service.ts
import {
  BadRequestException,
  Injectable,
  UnauthorizedException,
} from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { JwtService } from '@nestjs/jwt';
import { InjectRepository } from '@nestjs/typeorm';
import * as bcrypt from 'bcrypt';
import { Repository } from 'typeorm';
import { v4 as uuidv4 } from 'uuid';
import { User } from '../users/entities/user.entity';
import { LoginDto } from './dto/login.dto';
import { RegisterDto } from './dto/register.dto';
import { ResetPasswordRequestDto } from './dto/reset-password-request.dto';
import { ResetPasswordDto } from './dto/reset-password.dto';
import { PasswordReset } from './entities/password-reset.entity';
import { Session } from './entities/session.entity';

// Интерфейс за JWT payload
interface JwtPayload {
  sub: number;
  email: string;
  role: string;
}

@Injectable()
export class AuthService {
  constructor(
    @InjectRepository(User)
    private usersRepository: Repository<User>,
    @InjectRepository(PasswordReset)
    private passwordResetRepository: Repository<PasswordReset>,
    @InjectRepository(Session)
    private sessionRepository: Repository<Session>,
    private jwtService: JwtService,
    private configService: ConfigService,
  ) {}

  async register(
    registerDto: RegisterDto,
  ): Promise<{ user: User; token: string }> {
    const { email, password } = registerDto;

    // Проверка за съществуващ потребител
    const existingUser = await this.usersRepository.findOne({
      where: { email },
    });
    if (existingUser) {
      throw new BadRequestException('Потребител с този имейл вече съществува');
    }

    // Хеширане на паролата
    const salt = await bcrypt.genSalt();
    const passwordHash = await bcrypt.hash(password, salt);

    // Създаване на потребител
    const user = this.usersRepository.create({
      email,
      passwordHash,
      salt,
      role: 'user',
      isActive: true,
      failedLoginAttempts: 0,
      lastLogin: null,
    });

    await this.usersRepository.save(user);

    // Генериране на JWT токен
    const token = this.generateToken(user);

    return { user, token };
  }

  async login(loginDto: LoginDto): Promise<{ user: User; token: string }> {
    const { email, password } = loginDto;

    // Намиране на потребителя
    const user = await this.usersRepository.findOne({ where: { email } });
    if (!user) {
      throw new UnauthorizedException('Невалиден имейл или парола');
    }

    // Проверка дали акаунтът е активен
    if (!user.isActive) {
      throw new UnauthorizedException('Акаунтът е деактивиран');
    }

    // Валидиране на паролата
    const isPasswordValid = await bcrypt.compare(password, user.passwordHash);
    if (!isPasswordValid) {
      // Увеличаване на броя неуспешни опити
      user.failedLoginAttempts += 1;

      // Заключване на акаунта след 5 неуспешни опита
      if (user.failedLoginAttempts >= 5) {
        user.isActive = false;
      }

      await this.usersRepository.save(user);
      throw new UnauthorizedException('Невалиден имейл или парола');
    }

    // Нулиране на неуспешните опити и актуализиране на времето на последно влизане
    user.failedLoginAttempts = 0;
    user.lastLogin = new Date();
    await this.usersRepository.save(user);

    // Генериране на JWT токен
    const token = this.generateToken(user);

    return { user, token };
  }

  async resetPasswordRequest(
    resetPasswordRequestDto: ResetPasswordRequestDto,
  ): Promise<void> {
    const { email } = resetPasswordRequestDto;

    // Намиране на потребителя
    const user = await this.usersRepository.findOne({ where: { email } });
    if (!user) {
      // За сигурност, не разкриваме дали имейлът съществува
      return;
    }

    // Генериране на токен за рестартиране на паролата
    const token = uuidv4();
    const expiresAt = new Date();
    expiresAt.setHours(expiresAt.getHours() + 24); // Валиден за 24 часа

    // Съхраняване на токена
    const passwordReset = this.passwordResetRepository.create({
      userId: user.id,
      token,
      used: false,
      expiresAt,
    });
    await this.passwordResetRepository.save(passwordReset);

    // Тук бихме изпратили имейл с линк за рестартиране на паролата
    // TODO: Имплементирайте изпращане на имейл
    console.log(`Токен за рестартиране на парола: ${token}`);
  }

  async resetPassword(resetPasswordDto: ResetPasswordDto): Promise<void> {
    const { token, newPassword } = resetPasswordDto;

    // Намиране на валиден токен за рестартиране на парола
    const passwordReset = await this.passwordResetRepository.findOne({
      where: { token, used: false },
      relations: ['user'],
    });

    if (!passwordReset || passwordReset.expiresAt < new Date()) {
      throw new BadRequestException('Невалиден или изтекъл токен');
    }

    const user = passwordReset.user;

    // Хеширане на новата парола
    const salt = await bcrypt.genSalt();
    const passwordHash = await bcrypt.hash(newPassword, salt);

    // Актуализиране на паролата на потребителя
    user.passwordHash = passwordHash;
    user.salt = salt;
    await this.usersRepository.save(user);

    // Маркиране на токена като използван
    passwordReset.used = true;
    await this.passwordResetRepository.save(passwordReset);

    // Премахване на всички сесии на потребителя за по-голяма сигурност
    await this.sessionRepository.delete({ userId: user.id });
  }

  async validateUser(email: string, password: string): Promise<User | null> {
    const user = await this.usersRepository.findOne({ where: { email } });
    if (!user || !user.isActive) {
      return null;
    }

    const isPasswordValid = await bcrypt.compare(password, user.passwordHash);
    if (!isPasswordValid) {
      return null;
    }

    return user;
  }

  async validateToken(token: string): Promise<User | null> {
    try {
      const payload = this.jwtService.verify(token);
      const user = await this.usersRepository.findOne({
        where: { id: payload.sub },
      });
      return user;
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    } catch (_) {
      // Intentionally ignoring error
      return null;
    }
  }

  generateToken(user: User): string {
    const payload: JwtPayload = {
      email: user.email,
      sub: user.id,
      role: user.role,
    };
    return this.jwtService.sign(payload);
  }

  async logout(token: string): Promise<void> {
    // Намиране и изтриване на сесията
    await this.sessionRepository.delete({ token });
  }
}


services/auth/src/auth/entities
services/auth/src/auth/entities/password-reset.entity.ts
import { Column, Entity, Index, JoinColumn, ManyToOne } from 'typeorm';
import { BaseEntity } from '../../common/entities/base.entity';
import { User } from '../../users/entities/user.entity';

@Entity('password_resets')
export class PasswordReset extends BaseEntity {
  @Column({ name: 'user_id' })
  @Index('idx_password_reset_user_id')
  userId: number;

  @ManyToOne(() => User, (user) => user.passwordResets, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'user_id' })
  user: User;

  @Column({ length: 255 })
  @Index('idx_password_reset_token')
  token: string;

  @Column({ default: false })
  used: boolean;

  @Column({ name: 'expires_at', type: 'timestamp' })
  expiresAt: Date;
}


services/auth/src/auth/entities/session.entity.ts
import { Column, Entity, Index, JoinColumn, ManyToOne } from 'typeorm';
import { BaseEntity } from '../../common/entities/base.entity';
import { User } from '../../users/entities/user.entity';

@Entity('sessions')
export class Session extends BaseEntity {
  @Column({ name: 'user_id' })
  @Index('idx_session_user_id')
  userId: number;

  @ManyToOne(() => User, (user) => user.sessions, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'user_id' })
  user: User;

  @Column({ length: 255 })
  @Index('idx_session_token')
  token: string;

  @Column({ name: 'ip_address', type: 'varchar', length: 45, nullable: true })
  ipAddress: string | null;

  @Column({ name: 'user_agent', type: 'text', nullable: true })
  userAgent: string | null;

  @Column({ name: 'expires_at', type: 'timestamp' })
  expiresAt: Date;

  @Column({
    name: 'last_active',
    type: 'timestamp',
    default: () => 'CURRENT_TIMESTAMP',
  })
  lastActive: Date;
}


services/auth/src/auth/dto
services/auth/src/auth/dto/register.dto.ts
import { IsEmail, IsNotEmpty, Matches, MinLength } from 'class-validator';

export class RegisterDto {
  @IsEmail({}, { message: 'Моля, въведете валиден имейл адрес' })
  email: string;

  @IsNotEmpty({ message: 'Паролата е задължителна' })
  @MinLength(8, { message: 'Паролата трябва да бъде поне 8 символа' })
  @Matches(/((?=.*\d)|(?=.*\W+))(?![.\n])(?=.*[A-Z])(?=.*[a-z]).*$/, {
    message:
      'Паролата трябва да съдържа главна буква, малка буква и цифра/специален символ',
  })
  password: string;
}


services/auth/src/auth/dto/login.dto.ts
import { IsEmail, IsNotEmpty } from 'class-validator';

export class LoginDto {
  @IsEmail({}, { message: 'Моля, въведете валиден имейл адрес' })
  email: string;

  @IsNotEmpty({ message: 'Паролата е задължителна' })
  password: string;
}


services/auth/src/auth/dto/reset-password-request.dto.ts
import { IsEmail } from 'class-validator';

export class ResetPasswordRequestDto {
  @IsEmail({}, { message: 'Моля, въведете валиден имейл адрес' })
  email: string;
}


services/auth/src/auth/dto/reset-password.dto.ts
import { IsNotEmpty, Matches, MinLength } from 'class-validator';

export class ResetPasswordDto {
  @IsNotEmpty({ message: 'Токенът е задължителен' })
  token: string;

  @IsNotEmpty({ message: 'Новата парола е задължителна' })
  @MinLength(8, { message: 'Паролата трябва да бъде поне 8 символа' })
  @Matches(/((?=.*\d)|(?=.*\W+))(?![.\n])(?=.*[A-Z])(?=.*[a-z]).*$/, {
    message:
      'Паролата трябва да съдържа главна буква, малка буква и цифра/специален символ',
  })
  newPassword: string;
}


services/auth/src/auth/strategies
services/auth/src/auth/strategies/jwt.strategy.ts
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { PassportStrategy } from '@nestjs/passport';
import { InjectRepository } from '@nestjs/typeorm';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { Repository } from 'typeorm';
import { User } from '../../users/entities/user.entity';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(
    private readonly configService: ConfigService,
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
  ) {
    const secretKey = configService.get<string>('jwt.secret');
    if (!secretKey) {
      throw new Error('JWT secret key is not defined');
    }

    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: secretKey,
    });
  }

  async validate(payload: { sub: number; email: string }): Promise<User> {
    const user = await this.userRepository.findOne({
      where: { id: payload.sub },
    });
    if (!user || !user.isActive) {
      throw new UnauthorizedException('Невалиден потребител или токен');
    }
    return user;
  }
}


services/auth/src/auth/guards
services/auth/src/auth/guards/jwt-auth.guard.ts
import {
  ExecutionContext,
  Injectable,
  UnauthorizedException,
} from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
import { Observable } from 'rxjs';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {
    return super.canActivate(context);
  }

  handleRequest(err: any, user: any): any {
    if (err || !user) {
      throw err || new UnauthorizedException('Не сте оторизиран');
    }
    return user;
  }
}


services/auth/src/auth/guards/roles.guard.ts
import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';
import { Reflector } from '@nestjs/core';

interface RequestWithUser {
  user: {
    role: string;
  };
}

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const roles = this.reflector.get<string[]>('roles', context.getHandler());
    if (!roles) {
      return true;
    }
    const request = context.switchToHttp().getRequest<RequestWithUser>();
    const user = request.user;
    return roles.includes(user.role);
  }
}


services/auth/src/auth/decorators
services/auth/src/auth/decorators/roles.decorator.ts
import { SetMetadata } from '@nestjs/common';

export const Roles = (...roles: string[]) => SetMetadata('roles', roles);


services/auth/test
services/auth/test/jest-e2e.json
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}


services/auth/test/app.e2e-spec.ts
// services/auth/test/app.e2e-spec.ts
import { INestApplication } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { Test, TestingModule } from '@nestjs/testing';
import { TypeOrmModule } from '@nestjs/typeorm';
import * as request from 'supertest';
import { AuthModule } from '../src/auth/auth.module';
import { PasswordReset } from '../src/auth/entities/password-reset.entity';
import { Session } from '../src/auth/entities/session.entity';
import appConfig from '../src/config/app.config';
import { User } from '../src/users/entities/user.entity';
import { AppController } from './../src/app.controller';
import { AppService } from './../src/app.service';

describe('AppController (e2e)', () => {
  let app: INestApplication;

  // Увеличаваме таймаута до 30 секунди
  jest.setTimeout(30000);

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [
        // Настройка на ConfigModule
        ConfigModule.forRoot({
          isGlobal: true,
          load: [appConfig],
        }),
        // Директна TypeORM конфигурация за тестовата база данни
        TypeOrmModule.forRoot({
          type: 'postgres',
          host: 'localhost',
          port: 5433, // Порт, мапиран в docker-compose.test.yml
          username: 'test_user', // Потребител от docker-compose.test.yml
          password: 'test_password', // Парола от docker-compose.test.yml
          database: 'test_db', // База данни от docker-compose.test.yml
          entities: [User, PasswordReset, Session],
          synchronize: true, // Разрешаваме синхронизация за тестовете
          logging: false, // Изключваме logging за по-чисти тестови резултати
        }),
        // Импортираме AuthModule за достъп до всички необходими услуги
        AuthModule,
      ],
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  // Почистване след всички тестове
  afterAll(async () => {
    await app.close();
  });

  // Базов тест за проверка на работоспособност
  it('/ (GET)', () => {
    return request(app.getHttpServer())
      .get('/')
      .expect(200)
      .expect('Hello World!');
  });
});


services/auth/.prettierrc
[Бинарно или не-текстово съдържание не е показано]

services/auth/eslint.config.mjs
[Бинарно или не-текстово съдържание не е показано]

services/auth/nest-cli.json
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}


services/auth/package.json
{
  "name": "auth",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "cross-env jest --config ./test/jest-e2e.json --detectOpenHandles --forceExit"
  },
  "dependencies": {
    "@nestjs/common": "^11.0.1",
    "@nestjs/config": "^4.0.2",
    "@nestjs/core": "^11.0.1",
    "@nestjs/jwt": "^11.0.0",
    "@nestjs/passport": "^11.0.5",
    "@nestjs/platform-express": "^11.0.1",
    "@nestjs/typeorm": "^11.0.0",
    "bcrypt": "^5.1.1",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.2",
    "passport": "^0.7.0",
    "passport-jwt": "^4.0.1",
    "passport-local": "^1.0.0",
    "pg": "^8.15.6",
    "redis": "^4.7.1",
    "reflect-metadata": "^0.2.2",
    "rxjs": "^7.8.1",
    "typeorm": "^0.3.23",
    "uuid": "^11.1.0"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3.2.0",
    "@eslint/js": "^9.18.0",
    "@nestjs/cli": "^11.0.0",
    "@nestjs/schematics": "^11.0.0",
    "@nestjs/testing": "^11.0.1",
    "@swc/cli": "^0.6.0",
    "@swc/core": "^1.10.7",
    "@types/bcrypt": "^5.0.2",
    "@types/express": "^5.0.0",
    "@types/jest": "^29.5.14",
    "@types/node": "^22.10.7",
    "@types/passport-jwt": "^4.0.1",
    "@types/passport-local": "^1.0.38",
    "@types/supertest": "^6.0.2",
    "@types/uuid": "^10.0.0",
    "cross-env": "^7.0.3",
    "eslint": "^9.18.0",
    "eslint-config-prettier": "^10.0.1",
    "eslint-plugin-prettier": "^5.2.2",
    "globals": "^16.0.0",
    "jest": "^29.7.0",
    "prettier": "^3.4.2",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "^29.2.5",
    "ts-loader": "^9.5.2",
    "ts-node": "^10.9.2",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.7.3",
    "typescript-eslint": "^8.20.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}


services/auth/tsconfig.build.json
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}


services/auth/tsconfig.json
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2023",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": true,
    "forceConsistentCasingInFileNames": true,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "noFallthroughCasesInSwitch": false
  }
}


services/auth/.gitignore
# compiled output
/dist
/node_modules
/build

# Logs
logs
*.log
npm-debug.log*
pnpm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# temp directory
.temp
.tmp

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json


services/auth/.env
### Съдържание на .env файл ###
# services/auth/.env
# Database
DATABASE_HOST=localhost
DATABASE_PORT=5433
DATABASE_USERNAME=postgres
DATABASE_PASSWORD=postgres
DATABASE_NAME=learning_platform

# JWT
JWT_SECRET=your_jwt_secret_key_here
JWT_EXPIRES_IN=1h
JWT_REFRESH_EXPIRES_IN=7d

# Redis
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=redis_password

# App
PORT=3001
NODE_ENV=development

### Край на .env файл ###

services/auth/logs
services/user
services/user/Dockerfile
FROM node:20-alpine

WORKDIR /app

# За неразработени сървиси или за първоначално стартиране
# Създаваме минимално приложение
RUN echo '{ \
  "name": "microservice", \
  "version": "0.1.0", \
  "scripts": { \
    "start": "node server.js", \
    "start:dev": "node server.js" \
  } \
}' > package.json

RUN echo 'console.log("Service running on port 3000");\
const http = require("http");\
http.createServer((req, res) => {\
  res.writeHead(200, {"Content-Type": "application/json"});\
  res.end(JSON.stringify({status: "ok", service: "placeholder"}));\
}).listen(3000);' > server.js

EXPOSE 3000

CMD ["npm", "run", "start:dev"]

services/user/src
services/user/src/entities
services/user/src/entities/user-profile.entity.ts
import { BaseEntity } from '@shared/entities/base.entity';
import { Column, Entity, Index, JoinColumn, OneToOne } from 'typeorm';
import { User } from './user.entity';

@Entity('user_profiles')
export class UserProfile extends BaseEntity {
  @Column({ name: 'user_id', unique: true })
  @Index('idx_user_profile_user_id')
  userId: number;

  @OneToOne(() => User, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'user_id' })
  user: User;

  @Column({ name: 'first_name', length: 100, nullable: true })
  firstName: string | null;

  @Column({ name: 'last_name', length: 100, nullable: true })
  lastName: string | null;

  @Column({ name: 'avatar_url', length: 255, nullable: true })
  avatarUrl: string | null;

  @Column({ type: 'jsonb', nullable: true })
  preferences: Record<string, any> | null;
}


services/user/logs
services/course
services/course/Dockerfile
FROM node:20-alpine

WORKDIR /app

# За неразработени сървиси или за първоначално стартиране
# Създаваме минимално приложение
RUN echo '{ \
  "name": "microservice", \
  "version": "0.1.0", \
  "scripts": { \
    "start": "node server.js", \
    "start:dev": "node server.js" \
  } \
}' > package.json

RUN echo 'console.log("Service running on port 3000");\
const http = require("http");\
http.createServer((req, res) => {\
  res.writeHead(200, {"Content-Type": "application/json"});\
  res.end(JSON.stringify({status: "ok", service: "placeholder"}));\
}).listen(3000);' > server.js

EXPOSE 3000

CMD ["npm", "run", "start:dev"]

services/course/src
services/course/src/entities
services/course/src/entities/course.entity.ts
import { BaseEntity } from '@shared/entities/base.entity';
import { Column, Entity, OneToMany } from 'typeorm';
import { Chapter } from './chapter.entity';

@Entity('courses')
export class Course extends BaseEntity {
  @Column({ length: 255 })
  title: string;

  @Column({ type: 'text', nullable: true })
  description: string | null;

  @Column({ name: 'cover_image_url', length: 255, nullable: true })
  coverImageUrl: string | null;

  @Column({ type: 'jsonb', nullable: true })
  metadata: Record<string, any> | null;

  @Column({ name: 'is_active', default: true })
  isActive: boolean;

  @OneToMany(() => Chapter, (chapter) => chapter.course)
  chapters: Chapter[];
}


services/course/src/entities/chapter.entity.ts
import { BaseEntity } from '@shared/entities/base.entity';
import { Column, Entity, Index, JoinColumn, ManyToOne, OneToMany } from 'typeorm';
import { Content } from './content.entity';
import { Course } from './course.entity';

@Entity('chapters')
export class Chapter extends BaseEntity {
  @Column({ name: 'course_id' })
  @Index('idx_chapter_course_id')
  courseId: number;

  @ManyToOne(() => Course, (course) => course.chapters, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'course_id' })
  course: Course;

  @Column({ length: 255 })
  title: string;

  @Column({ type: 'text', nullable: true })
  description: string | null;

  @Column({ default: 0 })
  order: number;

  @OneToMany(() => Content, (content) => content.chapter)
  contents: Content[];
}


services/course/src/entities/content.entity.ts
import { BaseEntity } from '@shared/entities/base.entity';
import { Column, Entity, Index, JoinColumn, ManyToOne } from 'typeorm';
import { Chapter } from './chapter.entity';

@Entity('contents')
export class Content extends BaseEntity {
  @Column({ name: 'chapter_id' })
  @Index('idx_content_chapter_id')
  chapterId: number;

  @ManyToOne(() => Chapter, (chapter) => chapter.contents, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'chapter_id' })
  chapter: Chapter;

  @Column({ length: 255 })
  title: string;

  @Column({ type: 'text' })
  content: string;

  @Column({ name: 'content_type', length: 50, default: 'text' })
  contentType: string;

  @Column({ default: 0 })
  order: number;
}


services/course/src/entities/user-progress.entity.ts
import { User } from '@auth/entities/user.entity';
import { BaseEntity } from '@shared/entities/base.entity';
import { Column, Entity, Index, JoinColumn, ManyToOne } from 'typeorm';
import { Chapter } from './chapter.entity';
import { Content } from './content.entity';

@Entity('user_progress')
export class UserProgress extends BaseEntity {
  @Column({ name: 'user_id' })
  @Index('idx_user_progress_user_id')
  userId: number;

  @ManyToOne(() => User, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'user_id' })
  user: User;

  @Column({ name: 'chapter_id' })
  @Index('idx_user_progress_chapter_id')
  chapterId: number;

  @ManyToOne(() => Chapter, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'chapter_id' })
  chapter: Chapter;

  @Column({ name: 'content_id', nullable: true })
  contentId: number | null;

  @ManyToOne(() => Content, { onDelete: 'SET NULL', nullable: true })
  @JoinColumn({ name: 'content_id' })
  content: Content | null;

  @Column({ default: false })
  completed: boolean;

  @Column({ name: 'progress_percentage', default: 0 })
  progressPercentage: number;

  @Column({ name: 'last_accessed', type: 'timestamp', default: () => 'CURRENT_TIMESTAMP' })
  lastAccessed: Date;
}


services/course/src/modules
services/course/src/modules/courses
services/course/src/modules/courses/courses.service.ts
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { CacheService } from '@shared/modules/cache/cache.service';
import { Repository } from 'typeorm';
import { Course } from '../../entities/course.entity';

@Injectable()
export class CoursesService {
  constructor(
    @InjectRepository(Course)
    private coursesRepository: Repository<Course>,
    private cacheService: CacheService,
  ) {}

  async findAll(): Promise<Course[]> {
    const cacheKey = this.cacheService.generateKey('courses', 'all');

    return this.cacheService.getOrSet(
      cacheKey,
      () =>
        this.coursesRepository.find({
          where: { isActive: true },
          order: { title: 'ASC' },
        }),
      3600, // TTL: 1 час
    );
  }

  async findOne(id: number): Promise<Course> {
    const cacheKey = this.cacheService.generateKey('courses', id.toString());

    return this.cacheService.getOrSet(
      cacheKey,
      () =>
        this.coursesRepository.findOneOrFail({
          where: { id, isActive: true },
          relations: ['chapters'],
        }),
      3600, // TTL: 1 час
    );
  }

  async create(courseData: Partial<Course>): Promise<Course> {
    const course = this.coursesRepository.create(courseData);
    await this.coursesRepository.save(course);

    // Инвалидиране на кеша
    await this.cacheService.delete(this.cacheService.generateKey('courses', 'all'));

    return course;
  }

  async update(id: number, courseData: Partial<Course>): Promise<Course> {
    await this.coursesRepository.update(id, courseData);

    // Инвалидиране на съответните кеш записи
    await this.cacheService.delete(this.cacheService.generateKey('courses', id.toString()));
    await this.cacheService.delete(this.cacheService.generateKey('courses', 'all'));

    return this.findOne(id);
  }

  async remove(id: number): Promise<void> {
    await this.coursesRepository.delete(id);

    // Инвалидиране на съответните кеш записи
    await this.cacheService.delete(this.cacheService.generateKey('courses', id.toString()));
    await this.cacheService.delete(this.cacheService.generateKey('courses', 'all'));
  }
}


services/course/logs
services/test
services/test/Dockerfile
FROM node:20-alpine

WORKDIR /app

# За неразработени сървиси или за първоначално стартиране
# Създаваме минимално приложение
RUN echo '{ \
  "name": "microservice", \
  "version": "0.1.0", \
  "scripts": { \
    "start": "node server.js", \
    "start:dev": "node server.js" \
  } \
}' > package.json

RUN echo 'console.log("Service running on port 3000");\
const http = require("http");\
http.createServer((req, res) => {\
  res.writeHead(200, {"Content-Type": "application/json"});\
  res.end(JSON.stringify({status: "ok", service: "placeholder"}));\
}).listen(3000);' > server.js

EXPOSE 3000

CMD ["npm", "run", "start:dev"]

services/test/src
services/test/src/entities
services/test/src/entities/test.entity.ts
import { Chapter } from '@course/entities/chapter.entity';
import { BaseEntity } from '@shared/entities/base.entity';
import { Column, Entity, Index, JoinColumn, ManyToOne, OneToMany } from 'typeorm';
import { Question } from './question.entity';

@Entity('tests')
export class Test extends BaseEntity {
  @Column({ name: 'chapter_id' })
  @Index('idx_test_chapter_id')
  chapterId: number;

  @ManyToOne(() => Chapter, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'chapter_id' })
  chapter: Chapter;

  @Column({ length: 255 })
  title: string;

  @Column({ type: 'text', nullable: true })
  description: string | null;

  @Column({ name: 'time_limit', nullable: true })
  timeLimit: number | null;

  @Column({ name: 'passing_score', default: 60 })
  passingScore: number;

  @OneToMany(() => Question, (question) => question.test)
  questions: Question[];
}


services/test/src/entities/question.entity.ts
import { BaseEntity } from '@shared/entities/base.entity';
import { Column, Entity, Index, JoinColumn, ManyToOne } from 'typeorm';
import { Test } from './test.entity';

@Entity('questions')
export class Question extends BaseEntity {
  @Column({ name: 'test_id' })
  @Index('idx_question_test_id')
  testId: number;

  @ManyToOne(() => Test, (test) => test.questions, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'test_id' })
  test: Test;

  @Column({ name: 'question_text', type: 'text' })
  questionText: string;

  @Column({ name: 'question_type', length: 50, default: 'single_choice' })
  questionType: string;

  @Column({ type: 'jsonb' })
  options: any[];

  @Column({ name: 'correct_answers', type: 'jsonb' })
  correctAnswers: any[];

  @Column({ default: 1 })
  points: number;
}


services/test/src/entities/user-test-attempt.entity.ts
import { User } from '@auth/entities/user.entity';
import { BaseEntity } from '@shared/entities/base.entity';
import { Column, Entity, Index, JoinColumn, ManyToOne, OneToMany } from 'typeorm';
import { Test } from './test.entity';
import { UserAnswer } from './user-answer.entity';

@Entity('user_test_attempts')
export class UserTestAttempt extends BaseEntity {
  @Column({ name: 'user_id' })
  @Index('idx_user_test_attempts_user_id')
  userId: number;

  @ManyToOne(() => User, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'user_id' })
  user: User;

  @Column({ name: 'test_id' })
  @Index('idx_user_test_attempts_test_id')
  testId: number;

  @ManyToOne(() => Test, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'test_id' })
  test: Test;

  @Column({ default: 0 })
  score: number;

  @Column({ default: false })
  passed: boolean;

  @Column({ name: 'time_spent', default: 0 })
  timeSpent: number;

  @Column({ name: 'started_at', type: 'timestamp', default: () => 'CURRENT_TIMESTAMP' })
  startedAt: Date;

  @Column({ name: 'completed_at', type: 'timestamp', nullable: true })
  completedAt: Date | null;

  @OneToMany(() => UserAnswer, (answer) => answer.attempt)
  answers: UserAnswer[];
}


services/test/src/entities/user-answer.entity.ts
import { BaseEntity } from '@shared/entities/base.entity';
import { Column, Entity, Index, JoinColumn, ManyToOne } from 'typeorm';
import { Question } from './question.entity';
import { UserTestAttempt } from './user-test-attempt.entity';

@Entity('user_answers')
export class UserAnswer extends BaseEntity {
  @Column({ name: 'attempt_id' })
  @Index('idx_user_answers_attempt_id')
  attemptId: number;

  @ManyToOne(() => UserTestAttempt, (attempt) => attempt.answers, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'attempt_id' })
  attempt: UserTestAttempt;

  @Column({ name: 'question_id' })
  @Index('idx_user_answers_question_id')
  questionId: number;

  @ManyToOne(() => Question, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'question_id' })
  question: Question;

  @Column({ name: 'selected_answers', type: 'jsonb' })
  selectedAnswers: any[];

  @Column({ name: 'is_correct', default: false })
  isCorrect: boolean;

  @Column({ name: 'points_earned', default: 0 })
  pointsEarned: number;
}


services/test/logs
services/analytics
services/analytics/Dockerfile
FROM node:20-alpine

WORKDIR /app

# За неразработени сървиси или за първоначално стартиране
# Създаваме минимално приложение
RUN echo '{ \
  "name": "microservice", \
  "version": "0.1.0", \
  "scripts": { \
    "start": "node server.js", \
    "start:dev": "node server.js" \
  } \
}' > package.json

RUN echo 'console.log("Service running on port 3000");\
const http = require("http");\
http.createServer((req, res) => {\
  res.writeHead(200, {"Content-Type": "application/json"});\
  res.end(JSON.stringify({status: "ok", service: "placeholder"}));\
}).listen(3000);' > server.js

EXPOSE 3000

CMD ["npm", "run", "start:dev"]

services/analytics/logs
services/ads
services/ads/Dockerfile
FROM node:20-alpine

WORKDIR /app

# За неразработени сървиси или за първоначално стартиране
# Създаваме минимално приложение
RUN echo '{ \
  "name": "microservice", \
  "version": "0.1.0", \
  "scripts": { \
    "start": "node server.js", \
    "start:dev": "node server.js" \
  } \
}' > package.json

RUN echo 'console.log("Service running on port 3000");\
const http = require("http");\
http.createServer((req, res) => {\
  res.writeHead(200, {"Content-Type": "application/json"});\
  res.end(JSON.stringify({status: "ok", service: "placeholder"}));\
}).listen(3000);' > server.js

EXPOSE 3000

CMD ["npm", "run", "start:dev"]

services/ads/src
services/ads/src/entities
services/ads/src/entities/advertisement.entity.ts
import { BaseEntity } from '@shared/entities/base.entity';
import { Column, Entity, Index, OneToMany } from 'typeorm';
import { UserAdView } from './user-ad-view.entity';

@Entity('advertisements')
export class Advertisement extends BaseEntity {
  @Column({ length: 255 })
  title: string;

  @Column({ type: 'text', nullable: true })
  description: string | null;

  @Column({ name: 'image_url', length: 255 })
  imageUrl: string;

  @Column({ name: 'target_url', length: 255 })
  targetUrl: string;

  @Column({ name: 'start_date', type: 'timestamp' })
  @Index('idx_advertisement_dates')
  startDate: Date;

  @Column({ name: 'end_date', type: 'timestamp' })
  @Index('idx_advertisement_dates')
  endDate: Date;

  @Column({ name: 'is_active', default: true })
  @Index('idx_advertisement_is_active')
  isActive: boolean;

  @Column({ default: 0 })
  impressions: number;

  @Column({ default: 0 })
  clicks: number;

  @OneToMany(() => UserAdView, (view) => view.ad)
  views: UserAdView[];
}


services/ads/src/entities/user-ad-view.entity.ts
import { User } from '@auth/entities/user.entity';
import { BaseEntity } from '@shared/entities/base.entity';
import { Column, Entity, Index, JoinColumn, ManyToOne } from 'typeorm';
import { Advertisement } from './advertisement.entity';

@Entity('user_ad_views')
export class UserAdView extends BaseEntity {
  @Column({ name: 'user_id' })
  @Index('idx_user_ad_views_user_id')
  userId: number;

  @ManyToOne(() => User, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'user_id' })
  user: User;

  @Column({ name: 'ad_id' })
  @Index('idx_user_ad_views_ad_id')
  adId: number;

  @ManyToOne(() => Advertisement, (ad) => ad.views, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'ad_id' })
  ad: Advertisement;

  @Column({ default: false })
  clicked: boolean;

  @Column({ name: 'viewed_at', type: 'timestamp', default: () => 'CURRENT_TIMESTAMP' })
  viewedAt: Date;
}


services/ads/logs
services/shared
services/shared/src
services/shared/src/entities
services/shared/src/entities/base.entity.ts
import { CreateDateColumn, PrimaryGeneratedColumn, UpdateDateColumn } from 'typeorm';

export abstract class BaseEntity {
  @PrimaryGeneratedColumn()
  id: number;

  @CreateDateColumn({ name: 'created_at' })
  createdAt: Date;

  @UpdateDateColumn({ name: 'updated_at' })
  updatedAt: Date;
}


services/shared/src/modules
services/shared/src/modules/cache
services/shared/src/modules/cache/cache.module.ts
import { CacheModule as NestCacheModule } from '@nestjs/cache-manager';
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import * as redisStore from 'cache-manager-redis-store';
import { CacheService } from './cache.service';

@Module({
  imports: [
    NestCacheModule.registerAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: async (configService: ConfigService) => ({
        store: redisStore,
        host: configService.get<string>('REDIS_HOST', 'redis'),
        port: configService.get<number>('REDIS_PORT', 6379),
        password: configService.get<string>('REDIS_PASSWORD', ''),
        ttl: configService.get<number>('CACHE_TTL', 60 * 60), // По подразбиране 1 час
        max: configService.get<number>('CACHE_MAX_ITEMS', 10000),
        isGlobal: true,
      }),
    }),
  ],
  providers: [CacheService],
  exports: [CacheService],
})
export class CacheModule {}


services/shared/src/modules/cache/cache.service.ts
import { CACHE_MANAGER } from '@nestjs/cache-manager';
import { Inject, Injectable } from '@nestjs/common';
import { Cache } from 'cache-manager';

@Injectable()
export class CacheService {
  constructor(@Inject(CACHE_MANAGER) private cacheManager: Cache) {}

  async get<T>(key: string): Promise<T | undefined> {
    return this.cacheManager.get<T>(key);
  }

  async set<T>(key: string, value: T, ttl?: number): Promise<void> {
    await this.cacheManager.set(key, value, ttl);
  }

  async delete(key: string): Promise<void> {
    await this.cacheManager.del(key);
  }

  async reset(): Promise<void> {
    await this.cacheManager.reset();
  }

  // Добавяне на помощни методи, които улесняват работата с кеша

  async getOrSet<T>(key: string, factory: () => Promise<T>, ttl?: number): Promise<T> {
    const cachedValue = await this.get<T>(key);
    if (cachedValue !== undefined) {
      return cachedValue;
    }

    const value = await factory();
    await this.set(key, value, ttl);
    return value;
  }

  generateKey(...parts: (string | number)[]): string {
    return parts.join(':');
  }

  // Методи за работа с групи ключове
  async deleteByPrefix(prefix: string): Promise<void> {
    // Забележка: Това изисква достъп до Redis клиент или специфична имплементация
    // Като алтернатива, можете да поддържате списък с ключове по префикс
    // Тук е само примерна имплементация
    const client = (this.cacheManager as any).store.getClient?.();
    if (client) {
      const keys = await client.keys(`${prefix}*`);
      if (keys.length > 0) {
        await client.del(keys);
      }
    }
  }
}


services/shared/src/modules/database
services/shared/src/modules/database/migration.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { DataSource } from 'typeorm';

@Injectable()
export class MigrationService {
  private readonly logger = new Logger(MigrationService.name);

  constructor(private readonly dataSource: DataSource, private readonly configService: ConfigService) {}

  async runMigrations(): Promise<void> {
    // Проверка дали трябва автоматично да се изпълнят миграциите
    const autoMigrate = this.configService.get<boolean>('DATABASE_AUTO_MIGRATE', false);

    if (autoMigrate) {
      this.logger.log('Автоматично изпълнение на миграциите...');

      try {
        const migrations = await this.dataSource.runMigrations();
        this.logger.log(`Успешно изпълнени ${migrations.length} миграции`);
      } catch (error) {
        this.logger.error('Грешка при изпълнение на миграциите', error);
        throw error;
      }
    } else {
      this.logger.log('Автоматичното изпълнение на миграциите е изключено');
    }
  }
}


frontend
frontend/Dockerfile
FROM node:20-alpine

WORKDIR /app

# За неразработен frontend или за първоначално стартиране
RUN echo '{ \
  "name": "frontend", \
  "version": "0.1.0", \
  "scripts": { \
    "start": "node server.js" \
  } \
}' > package.json

RUN echo 'console.log("Frontend running on port 3000");\
const http = require("http");\
http.createServer((req, res) => {\
  res.writeHead(200, {"Content-Type": "text/html"});\
  res.end("<html><body><h1>Frontend Placeholder</h1><p>This is a temporary frontend.</p></body></html>");\
}).listen(3000);' > server.js

EXPOSE 3000

CMD ["npm", "start"]

nginx
nginx/Dockerfile
FROM nginx:1.25-alpine

# Проверка дали nginx.conf съществува, ако не - създаване на прост такъв
RUN [ -f /etc/nginx/nginx.conf ] || echo 'events {\n  worker_connections 1024;\n}\n\nhttp {\n  server {\n    listen 80;\n    location / {\n      return 200 "Nginx placeholder running";\n    }\n  }\n}' > /etc/nginx/nginx.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]

nginx/nginx.conf


nginx/logs
nginx/logs/error.log
[Бинарно или не-текстово съдържание не е показано]

db
db/init.sql


db/migrations
db/migrations/package.json
{
  "name": "learning-platform-migrations",
  "version": "1.0.0",
  "description": "Migrations for Learning Platform",
  "scripts": {
    "typeorm": "typeorm-ts-node-commonjs",
    "migration:generate": "npm run typeorm migration:generate -- -d ./typeorm.config.ts",
    "migration:create": "npm run typeorm migration:create",
    "migration:run": "npm run typeorm migration:run -- -d ./typeorm.config.ts",
    "migration:revert": "npm run typeorm migration:revert -- -d ./typeorm.config.ts",
    "migration:show": "npm run typeorm migration:show -- -d ./typeorm.config.ts",
    "schema:sync": "npm run typeorm schema:sync -- -d ./typeorm.config.ts",
    "schema:log": "npm run typeorm schema:log -- -d ./typeorm.config.ts",
    "schema:drop": "npm run typeorm schema:drop -- -d ./typeorm.config.ts",
    "test": "jest --config=jest.config.js",
    "test:watch": "jest --config=jest.config.js --watch"
  },
  "dependencies": {
    "@nestjs/typeorm": "^11.0.0",
    "dotenv": "^16.5.0",
    "pg": "^8.15.6",
    "typeorm": "^0.3.22"
  },
  "devDependencies": {
    "@types/jest": "^29.5.14",
    "@types/node": "^22.15.12",
    "jest": "^29.7.0",
    "ts-jest": "^29.3.2",
    "ts-node": "^10.9.2",
    "typescript": "^5.8.3"
  }
}


db/migrations/typeorm.config.ts
import * as dotenv from 'dotenv';
import { DataSource } from 'typeorm';
import { CreateInitialSchema1683456789000 } from './migrations/1683456789000-CreateInitialSchema';
import { AddAdditionalIndices1683456789001 } from './migrations/1683456789001-AddAdditionalIndices';

dotenv.config();

export const AppDataSource = new DataSource({
  type: 'postgres',
  host: process.env.DB_HOST || 'localhost',
  port: parseInt(process.env.DB_PORT || '5433', 10),
  username: process.env.DB_USER || 'postgres',
  password: process.env.DB_PASSWORD || 'postgres',
  database: process.env.DB_NAME || 'learning_platform',
  synchronize: false,
  logging: process.env.NODE_ENV !== 'production',
  entities: [],
  migrations: [CreateInitialSchema1683456789000, AddAdditionalIndices1683456789001],
  migrationsTableName: 'migrations_history',
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,
});


db/migrations/tests
db/migrations/tests/migrations.spec.ts
import { afterAll, beforeAll, describe, expect, it } from '@jest/globals';
import * as dotenv from 'dotenv';
import { DataSource } from 'typeorm';
import { CreateInitialSchema1683456789000 } from '../migrations/1683456789000-CreateInitialSchema';
import { AddAdditionalIndices1683456789001 } from '../migrations/1683456789001-AddAdditionalIndices';

// Зареждане на .env файла
dotenv.config();

// Извличане на настройки от средата
const dbConfig = {
  host: process.env.DB_HOST || 'localhost',
  port: parseInt(process.env.DB_PORT || '5433', 10),
  username: process.env.DB_USER || 'postgres',
  password: process.env.DB_PASSWORD || 'postgres',
  database: process.env.DB_NAME || 'learning_platform',
};

describe('Database Migrations', () => {
  let dataSource: DataSource;

  beforeAll(async () => {
    try {
      // Настройка за използване на реалната база данни
      dataSource = new DataSource({
        type: 'postgres',
        host: dbConfig.host,
        port: dbConfig.port,
        username: dbConfig.username,
        password: dbConfig.password,
        database: dbConfig.database,
        synchronize: false,
        logging: true,
        entities: [],
        migrations: [CreateInitialSchema1683456789000, AddAdditionalIndices1683456789001],
        migrationsTableName: 'migrations_history_test',
      });

      console.log('Опит за свързване с базата данни...');
      console.log(`Настройки: ${dbConfig.username}@${dbConfig.host}:${dbConfig.port}/${dbConfig.database}`);
      await dataSource.initialize();
      console.log('Връзката с базата данни е успешна!');
    } catch (error) {
      console.error('Грешка при свързване с базата данни:', error);
      throw error;
    }
  });

  afterAll(async () => {
    if (dataSource && dataSource.isInitialized) {
      await dataSource.destroy();
    }
  });

  it('should run migrations up successfully', async () => {
    // Изпълнение на миграциите
    await dataSource.runMigrations();

    // Проверка дали миграциите са успешно изпълнени
    const appliedMigrations = await dataSource.query(`
      SELECT * FROM migrations_history_test ORDER BY id ASC
    `);

    expect(appliedMigrations.length).toBeGreaterThan(0);
  });

  it('should run migrations down successfully', async () => {
    // Връщане на последната миграция
    await dataSource.undoLastMigration();

    // Проверка дали миграцията е успешно върната
    const appliedMigrations = await dataSource.query(`
      SELECT * FROM migrations_history_test ORDER BY id ASC
    `);

    // Трябва да има с една миграция по-малко
    const migrationClasses = [CreateInitialSchema1683456789000, AddAdditionalIndices1683456789001];

    expect(appliedMigrations.length).toBe(migrationClasses.length - 1);
  });
});


db/migrations/tests/db-migration-connection-test.ts
import { DataSource } from 'typeorm';
import { CreateInitialSchema1683456789000 } from '../migrations/1683456789000-CreateInitialSchema';
import { AddAdditionalIndices1683456789001 } from '../migrations/1683456789001-AddAdditionalIndices';

async function testMigrationLoading() {
  try {
    // Конфигуриране на връзката с реалната база данни
    const dataSource = new DataSource({
      type: 'postgres',
      host: 'localhost',
      port: 5433,
      username: 'postgres',
      password: 'postgres',
      database: 'learning_platform',
      synchronize: false,
      logging: true,
      entities: [],
      migrations: [CreateInitialSchema1683456789000, AddAdditionalIndices1683456789001],
      migrationsTableName: 'migrations_history_test',
    });

    console.log('Опит за свързване с базата данни...');
    await dataSource.initialize();
    console.log('Връзката с базата данни е успешна!');

    console.log('Опит за извличане на миграциите...');
    const migrations = dataSource.migrations;
    console.log(`Намерени са ${migrations.length} миграции:`);
    migrations.forEach((m) => console.log(`- ${m.name || m.constructor.name}`));

    // Правилно затваряне на връзката
    await dataSource.destroy();
    process.exit(0);
  } catch (error) {
    console.error('Грешка:', error);
    process.exit(1);
  }
}

// Стартиране на тестовата функция
testMigrationLoading();


db/migrations/jest.config.js
// db/migrations/jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  testMatch: ['**/tests/**/*.spec.ts'],
  transform: {
    '^.+\\.tsx?$': 'ts-jest',
  },
  moduleFileExtensions: ['ts', 'js', 'json'],
  testPathIgnorePatterns: ['/node_modules/'],
  collectCoverage: true,
  coverageDirectory: 'coverage',
  collectCoverageFrom: ['migrations/**/*.ts'],
};


db/migrations/tsconfig.test.json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "types": [
      "node",
      "jest"
    ],
    "esModuleInterop": true
  },
  "include": [
    "tests/**/*.ts",
    "migrations/**/*.ts",
    "typeorm.config.ts"
  ]
}

db/migrations/tsconfig.json
{
  "compilerOptions": {
    "target": "es2018",
    "module": "commonjs",
    "moduleResolution": "node",
    "declaration": true,
    "outDir": "./dist",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "removeComments": true,
    "resolveJsonModule": true,
    "baseUrl": ".",
    "paths": {
      "@/*": [
        "./*"
      ]
    },
    "types": [
      "node",
      "jest"
    ] // Добавете това
  },
  "include": [
    "migrations/**/*.ts",
    "typeorm.config.ts",
    "tests/**/*.ts" // Добавете това
  ],
  "exclude": [
    "node_modules"
  ]
}

db/migrations/.env
### Съдържание на .env файл ###
TEST_DB_HOST=localhost
TEST_DB_PORT=5433
TEST_DB_USER=test_user
TEST_DB_PASSWORD=test_password
TEST_DB_NAME=test_db

### Край на .env файл ###

db/migrations/.env.test
### Съдържание на .env файл ###
TEST_DB_HOST=localhost
TEST_DB_PORT=5433
TEST_DB_USER=test_user
TEST_DB_PASSWORD=test_password
TEST_DB_NAME=test_db

### Край на .env файл ###

db/migrations/migrations
db/migrations/migrations/1683456789000-CreateInitialSchema.ts
// db/migrations/migrations/1683456789000-CreateInitialSchema.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class CreateInitialSchema1683456789000 implements MigrationInterface {
  name = 'CreateInitialSchema1683456789000';

  public async up(queryRunner: QueryRunner): Promise<void> {
    // Създаване на таблица Users
    await queryRunner.query(`
      CREATE TABLE "users" (
        "id" SERIAL PRIMARY KEY,
        "email" VARCHAR(255) NOT NULL UNIQUE,
        "password_hash" VARCHAR(255) NOT NULL,
        "salt" VARCHAR(255) NOT NULL,
        "role" VARCHAR(50) NOT NULL DEFAULT 'user',
        "is_active" BOOLEAN NOT NULL DEFAULT true,
        "failed_login_attempts" INTEGER NOT NULL DEFAULT 0,
        "last_login" TIMESTAMP,
        "created_at" TIMESTAMP NOT NULL DEFAULT now(),
        "updated_at" TIMESTAMP NOT NULL DEFAULT now()
      )
    `);

    // Създаване на таблица UserProfiles
    await queryRunner.query(`
      CREATE TABLE "user_profiles" (
        "id" SERIAL PRIMARY KEY,
        "user_id" INTEGER NOT NULL UNIQUE,
        "first_name" VARCHAR(100),
        "last_name" VARCHAR(100),
        "avatar_url" VARCHAR(255),
        "preferences" JSONB,
        "created_at" TIMESTAMP NOT NULL DEFAULT now(),
        "updated_at" TIMESTAMP NOT NULL DEFAULT now(),
        CONSTRAINT "fk_user_profiles_user" FOREIGN KEY ("user_id") REFERENCES "users" ("id") ON DELETE CASCADE
      )
    `);

    // Създаване на таблица Courses
    await queryRunner.query(`
      CREATE TABLE "courses" (
        "id" SERIAL PRIMARY KEY,
        "title" VARCHAR(255) NOT NULL,
        "description" TEXT,
        "cover_image_url" VARCHAR(255),
        "metadata" JSONB,
        "is_active" BOOLEAN NOT NULL DEFAULT true,
        "created_at" TIMESTAMP NOT NULL DEFAULT now(),
        "updated_at" TIMESTAMP NOT NULL DEFAULT now()
      )
    `);

    // Създаване на таблица Chapters
    await queryRunner.query(`
      CREATE TABLE "chapters" (
        "id" SERIAL PRIMARY KEY,
        "course_id" INTEGER NOT NULL,
        "title" VARCHAR(255) NOT NULL,
        "description" TEXT,
        "order" INTEGER NOT NULL DEFAULT 0,
        "created_at" TIMESTAMP NOT NULL DEFAULT now(),
        "updated_at" TIMESTAMP NOT NULL DEFAULT now(),
        CONSTRAINT "fk_chapters_course" FOREIGN KEY ("course_id") REFERENCES "courses" ("id") ON DELETE CASCADE
      )
    `);

    // Създаване на таблица Contents
    await queryRunner.query(`
      CREATE TABLE "contents" (
        "id" SERIAL PRIMARY KEY,
        "chapter_id" INTEGER NOT NULL,
        "title" VARCHAR(255) NOT NULL,
        "content" TEXT NOT NULL,
        "content_type" VARCHAR(50) NOT NULL DEFAULT 'text',
        "order" INTEGER NOT NULL DEFAULT 0,
        "created_at" TIMESTAMP NOT NULL DEFAULT now(),
        "updated_at" TIMESTAMP NOT NULL DEFAULT now(),
        CONSTRAINT "fk_contents_chapter" FOREIGN KEY ("chapter_id") REFERENCES "chapters" ("id") ON DELETE CASCADE
      )
    `);

    // Създаване на таблица UserProgress
    await queryRunner.query(`
      CREATE TABLE "user_progress" (
        "id" SERIAL PRIMARY KEY,
        "user_id" INTEGER NOT NULL,
        "chapter_id" INTEGER NOT NULL,
        "content_id" INTEGER,
        "completed" BOOLEAN NOT NULL DEFAULT false,
        "progress_percentage" INTEGER NOT NULL DEFAULT 0,
        "last_accessed" TIMESTAMP NOT NULL DEFAULT now(),
        "created_at" TIMESTAMP NOT NULL DEFAULT now(),
        "updated_at" TIMESTAMP NOT NULL DEFAULT now(),
        CONSTRAINT "fk_user_progress_user" FOREIGN KEY ("user_id") REFERENCES "users" ("id") ON DELETE CASCADE,
        CONSTRAINT "fk_user_progress_chapter" FOREIGN KEY ("chapter_id") REFERENCES "chapters" ("id") ON DELETE CASCADE,
        CONSTRAINT "fk_user_progress_content" FOREIGN KEY ("content_id") REFERENCES "contents" ("id") ON DELETE SET NULL
      )
    `);

    // Създаване на таблица Tests
    await queryRunner.query(`
      CREATE TABLE "tests" (
        "id" SERIAL PRIMARY KEY,
        "chapter_id" INTEGER NOT NULL,
        "title" VARCHAR(255) NOT NULL,
        "description" TEXT,
        "time_limit" INTEGER,
        "passing_score" INTEGER NOT NULL DEFAULT 60,
        "created_at" TIMESTAMP NOT NULL DEFAULT now(),
        "updated_at" TIMESTAMP NOT NULL DEFAULT now(),
        CONSTRAINT "fk_tests_chapter" FOREIGN KEY ("chapter_id") REFERENCES "chapters" ("id") ON DELETE CASCADE
      )
    `);

    // Създаване на таблица Questions
    await queryRunner.query(`
      CREATE TABLE "questions" (
        "id" SERIAL PRIMARY KEY,
        "test_id" INTEGER NOT NULL,
        "question_text" TEXT NOT NULL,
        "question_type" VARCHAR(50) NOT NULL DEFAULT 'single_choice',
        "options" JSONB NOT NULL,
        "correct_answers" JSONB NOT NULL,
        "points" INTEGER NOT NULL DEFAULT 1,
        "created_at" TIMESTAMP NOT NULL DEFAULT now(),
        "updated_at" TIMESTAMP NOT NULL DEFAULT now(),
        CONSTRAINT "fk_questions_test" FOREIGN KEY ("test_id") REFERENCES "tests" ("id") ON DELETE CASCADE
      )
    `);

    // Създаване на таблица UserTestAttempts
    await queryRunner.query(`
      CREATE TABLE "user_test_attempts" (
        "id" SERIAL PRIMARY KEY,
        "user_id" INTEGER NOT NULL,
        "test_id" INTEGER NOT NULL,
        "score" INTEGER NOT NULL DEFAULT 0,
        "passed" BOOLEAN NOT NULL DEFAULT false,
        "time_spent" INTEGER NOT NULL DEFAULT 0,
        "started_at" TIMESTAMP NOT NULL DEFAULT now(),
        "completed_at" TIMESTAMP,
        CONSTRAINT "fk_user_test_attempts_user" FOREIGN KEY ("user_id") REFERENCES "users" ("id") ON DELETE CASCADE,
        CONSTRAINT "fk_user_test_attempts_test" FOREIGN KEY ("test_id") REFERENCES "tests" ("id") ON DELETE CASCADE
      )
    `);

    // Създаване на таблица UserAnswers
    await queryRunner.query(`
      CREATE TABLE "user_answers" (
        "id" SERIAL PRIMARY KEY,
        "attempt_id" INTEGER NOT NULL,
        "question_id" INTEGER NOT NULL,
        "selected_answers" JSONB NOT NULL,
        "is_correct" BOOLEAN NOT NULL DEFAULT false,
        "points_earned" INTEGER NOT NULL DEFAULT 0,
        "created_at" TIMESTAMP NOT NULL DEFAULT now(),
        CONSTRAINT "fk_user_answers_attempt" FOREIGN KEY ("attempt_id") REFERENCES "user_test_attempts" ("id") ON DELETE CASCADE,
        CONSTRAINT "fk_user_answers_question" FOREIGN KEY ("question_id") REFERENCES "questions" ("id") ON DELETE CASCADE
      )
    `);

    // Създаване на таблица Advertisements
    await queryRunner.query(`
      CREATE TABLE "advertisements" (
        "id" SERIAL PRIMARY KEY,
        "title" VARCHAR(255) NOT NULL,
        "description" TEXT,
        "image_url" VARCHAR(255) NOT NULL,
        "target_url" VARCHAR(255) NOT NULL,
        "start_date" TIMESTAMP NOT NULL,
        "end_date" TIMESTAMP NOT NULL,
        "is_active" BOOLEAN NOT NULL DEFAULT true,
        "impressions" INTEGER NOT NULL DEFAULT 0,
        "clicks" INTEGER NOT NULL DEFAULT 0,
        "created_at" TIMESTAMP NOT NULL DEFAULT now(),
        "updated_at" TIMESTAMP NOT NULL DEFAULT now()
      )
    `);

    // Създаване на таблица UserAdViews
    await queryRunner.query(`
      CREATE TABLE "user_ad_views" (
        "id" SERIAL PRIMARY KEY,
        "user_id" INTEGER NOT NULL,
        "ad_id" INTEGER NOT NULL,
        "clicked" BOOLEAN NOT NULL DEFAULT false,
        "viewed_at" TIMESTAMP NOT NULL DEFAULT now(),
        CONSTRAINT "fk_user_ad_views_user" FOREIGN KEY ("user_id") REFERENCES "users" ("id") ON DELETE CASCADE,
        CONSTRAINT "fk_user_ad_views_ad" FOREIGN KEY ("ad_id") REFERENCES "advertisements" ("id") ON DELETE CASCADE
      )
    `);

    // Създаване на таблица PasswordResets
    await queryRunner.query(`
      CREATE TABLE "password_resets" (
        "id" SERIAL PRIMARY KEY,
        "user_id" INTEGER NOT NULL,
        "token" VARCHAR(255) NOT NULL,
        "used" BOOLEAN NOT NULL DEFAULT false,
        "expires_at" TIMESTAMP NOT NULL,
        "created_at" TIMESTAMP NOT NULL DEFAULT now(),
        CONSTRAINT "fk_password_resets_user" FOREIGN KEY ("user_id") REFERENCES "users" ("id") ON DELETE CASCADE
      )
    `);

    // Създаване на таблица Sessions
    await queryRunner.query(`
      CREATE TABLE "sessions" (
        "id" SERIAL PRIMARY KEY,
        "user_id" INTEGER NOT NULL,
        "token" VARCHAR(255) NOT NULL,
        "ip_address" VARCHAR(45),
        "user_agent" TEXT,
        "expires_at" TIMESTAMP NOT NULL,
        "created_at" TIMESTAMP NOT NULL DEFAULT now(),
        "last_active" TIMESTAMP NOT NULL DEFAULT now(),
        CONSTRAINT "fk_sessions_user" FOREIGN KEY ("user_id") REFERENCES "users" ("id") ON DELETE CASCADE
      )
    `);

    // Създаване на индекси за оптимизация на заявките
    await queryRunner.query(`CREATE INDEX "idx_user_email" ON "users" ("email")`);
    await queryRunner.query(`CREATE INDEX "idx_user_profile_user_id" ON "user_profiles" ("user_id")`);
    await queryRunner.query(`CREATE INDEX "idx_chapter_course_id" ON "chapters" ("course_id")`);
    await queryRunner.query(`CREATE INDEX "idx_content_chapter_id" ON "contents" ("chapter_id")`);
    await queryRunner.query(`CREATE INDEX "idx_user_progress_user_id" ON "user_progress" ("user_id")`);
    await queryRunner.query(`CREATE INDEX "idx_user_progress_chapter_id" ON "user_progress" ("chapter_id")`);
    await queryRunner.query(`CREATE INDEX "idx_test_chapter_id" ON "tests" ("chapter_id")`);
    await queryRunner.query(`CREATE INDEX "idx_question_test_id" ON "questions" ("test_id")`);
    await queryRunner.query(`CREATE INDEX "idx_user_test_attempts_user_id" ON "user_test_attempts" ("user_id")`);
    await queryRunner.query(`CREATE INDEX "idx_user_test_attempts_test_id" ON "user_test_attempts" ("test_id")`);
    await queryRunner.query(`CREATE INDEX "idx_user_answers_attempt_id" ON "user_answers" ("attempt_id")`);
    await queryRunner.query(`CREATE INDEX "idx_user_answers_question_id" ON "user_answers" ("question_id")`);
    await queryRunner.query(`CREATE INDEX "idx_advertisement_is_active" ON "advertisements" ("is_active")`);
    await queryRunner.query(`CREATE INDEX "idx_advertisement_dates" ON "advertisements" ("start_date", "end_date")`);
    await queryRunner.query(`CREATE INDEX "idx_user_ad_views_user_id" ON "user_ad_views" ("user_id")`);
    await queryRunner.query(`CREATE INDEX "idx_user_ad_views_ad_id" ON "user_ad_views" ("ad_id")`);
    await queryRunner.query(`CREATE INDEX "idx_password_reset_token" ON "password_resets" ("token")`);
    await queryRunner.query(`CREATE INDEX "idx_password_reset_user_id" ON "password_resets" ("user_id")`);
    await queryRunner.query(`CREATE INDEX "idx_session_token" ON "sessions" ("token")`);
    await queryRunner.query(`CREATE INDEX "idx_session_user_id" ON "sessions" ("user_id")`);

    // Създаване на админ потребител (закоментирано, ще се създаде ръчно по-късно)
    /*
    await queryRunner.query(`
      INSERT INTO "users" ("email", "password_hash", "salt", "role", "is_active")
      VALUES ('admin@example.com', 'HASH_PLACEHOLDER', 'SALT_PLACEHOLDER', 'admin', true)
    `);
    */
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    // Изтриване на таблиците в обратен ред
    await queryRunner.query(`DROP TABLE IF EXISTS "sessions" CASCADE`);
    await queryRunner.query(`DROP TABLE IF EXISTS "password_resets" CASCADE`);
    await queryRunner.query(`DROP TABLE IF EXISTS "user_ad_views" CASCADE`);
    await queryRunner.query(`DROP TABLE IF EXISTS "advertisements" CASCADE`);
    await queryRunner.query(`DROP TABLE IF EXISTS "user_answers" CASCADE`);
    await queryRunner.query(`DROP TABLE IF EXISTS "user_test_attempts" CASCADE`);
    await queryRunner.query(`DROP TABLE IF EXISTS "questions" CASCADE`);
    await queryRunner.query(`DROP TABLE IF EXISTS "tests" CASCADE`);
    await queryRunner.query(`DROP TABLE IF EXISTS "user_progress" CASCADE`);
    await queryRunner.query(`DROP TABLE IF EXISTS "contents" CASCADE`);
    await queryRunner.query(`DROP TABLE IF EXISTS "chapters" CASCADE`);
    await queryRunner.query(`DROP TABLE IF EXISTS "courses" CASCADE`);
    await queryRunner.query(`DROP TABLE IF EXISTS "user_profiles" CASCADE`);
    await queryRunner.query(`DROP TABLE IF EXISTS "users" CASCADE`);
  }
}


db/migrations/migrations/1683456789001-AddAdditionalIndices.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddAdditionalIndices1683456789001 implements MigrationInterface {
  public async up(queryRunner: QueryRunner): Promise<void> {
    // Добавяне на комбиниран индекс за потребителски прогрес
    await queryRunner.query(`
      CREATE INDEX idx_user_progress_user_chapter ON user_progress (user_id, chapter_id)
    `);

    // Добавяне на индекс за търсене на съдържание
    await queryRunner.query(`
      CREATE INDEX idx_content_title_text ON contents USING gin(to_tsvector('simple', title || ' ' || content))
    `);

    // Добавяне на комбиниран индекс за тестови опити
    await queryRunner.query(`
      CREATE INDEX idx_user_test_attempts_user_test ON user_test_attempts (user_id, test_id)
    `);

    // Добавяне на индекс за търсене на курсове
    await queryRunner.query(`
      CREATE INDEX idx_course_title_description ON courses USING gin(to_tsvector('simple', title || ' ' || COALESCE(description, '')))
    `);

    // Индекс за статистики на реклами
    await queryRunner.query(`
      CREATE INDEX idx_advertisement_status ON advertisements (is_active, start_date, end_date)
    `);

    // Индекс за поглеждане на реклами от потребители
    await queryRunner.query(`
      CREATE INDEX idx_user_ad_views_user_viewed ON user_ad_views (user_id, viewed_at)
    `);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`DROP INDEX IF EXISTS idx_user_progress_user_chapter`);
    await queryRunner.query(`DROP INDEX IF EXISTS idx_content_title_text`);
    await queryRunner.query(`DROP INDEX IF EXISTS idx_user_test_attempts_user_test`);
    await queryRunner.query(`DROP INDEX IF EXISTS idx_course_title_description`);
    await queryRunner.query(`DROP INDEX IF EXISTS idx_advertisement_status`);
    await queryRunner.query(`DROP INDEX IF EXISTS idx_user_ad_views_user_viewed`);
  }
}


db/optimization
db/optimization/query-analysis.sql
-- Анализира всички таблици
ANALYZE;

-- Включване на времето за изпълнение на заявките
\timing on

-- Проверка за бавни заявки от потребителските прогреси
EXPLAIN ANALYZE
SELECT up.*, c.title as chapter_title, co.title as content_title
FROM user_progress up
JOIN chapters c ON up.chapter_id = c.id
LEFT JOIN contents co ON up.content_id = co.id
WHERE up.user_id = 1
ORDER BY c.order, co.order;

-- Оптимизирана версия:
EXPLAIN ANALYZE
SELECT up.*, c.title as chapter_title, co.title as content_title
FROM user_progress up
JOIN chapters c ON up.chapter_id = c.id
LEFT JOIN contents co ON up.content_id = co.id
WHERE up.user_id = 1
ORDER BY c.order, co.order;

-- Проверка за бавни заявки при вземане на тестове с въпроси
EXPLAIN ANALYZE
SELECT t.*, q.*
FROM tests t
JOIN questions q ON q.test_id = t.id
WHERE t.chapter_id = 1
ORDER BY q.id;

-- Оптимизирана версия:
EXPLAIN ANALYZE
SELECT t.*, q.*
FROM tests t
JOIN questions q ON q.test_id = t.id
WHERE t.chapter_id = 1
ORDER BY q.id;

-- Препоръки за партициониране на големи таблици
-- Например, партициониране на user_answers по месеци:

/*
CREATE TABLE user_answers_partitioned (
    id SERIAL,
    attempt_id INTEGER NOT NULL,
    question_id INTEGER NOT NULL,
    selected_answers JSONB NOT NULL,
    is_correct BOOLEAN NOT NULL DEFAULT false,
    points_earned INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMP NOT NULL DEFAULT now()
) PARTITION BY RANGE (created_at);

CREATE TABLE user_answers_y2023m01 PARTITION OF user_answers_partitioned
    FOR VALUES FROM ('2023-01-01') TO ('2023-02-01');

CREATE TABLE user_answers_y2023m02 PARTITION OF user_answers_partitioned
    FOR VALUES FROM ('2023-02-01') TO ('2023-03-01');

-- и т.н. за всеки месец
*/

-- Потребителски дефинирани индекси за специфични заявки
-- Например, индекс за търсене в JSON полета:

/*
CREATE INDEX idx_question_options ON questions USING gin(options);
CREATE INDEX idx_question_correct_answers ON questions USING gin(correct_answers);
*/

-- Настройка на автовакуум за често променящи се таблици
/*
ALTER TABLE user_progress SET (
    autovacuum_vacuum_scale_factor = 0.05,
    autovacuum_analyze_scale_factor = 0.025
);
*/

db/scripts
db/scripts/manage-migrations.sh
#!/bin/bash
# db/scripts/manage-migrations.sh

# Цветове за терминала
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Функция за показване на помощна информация
show_help() {
    echo -e "${BLUE}Управление на миграциите за Учебната платформа${NC}"
    echo
    echo "Употреба:"
    echo "  $0 [команда] [опции]"
    echo
    echo "Команди:"
    echo "  generate [име]     Генерира нова миграция с даденото име"
    echo "  run                Изпълнява всички неприложени миграции"
    echo "  revert             Връща последната миграция"
    echo "  revert-all         Връща всички миграции"
    echo "  status             Показва статуса на миграциите"
    echo "  create-admin       Създава администраторски потребител"
    echo "  backup             Създава резервно копие на базата данни"
    echo "  restore [файл]     Възстановява базата данни от резервно копие"
    echo "  help               Показва тази помощна информация"
    echo
    echo "Примери:"
    echo "  $0 generate AddUserRoles"
    echo "  $0 run"
    echo "  $0 revert"
    echo "  $0 backup"
    echo "  $0 restore backup-2023-05-01.sql"
    echo
}

# Функция за генериране на миграция
generate_migration() {
    if [ -z "$1" ]; then
        echo -e "${RED}Грешка: Липсва име на миграцията${NC}"
        echo "Пример: $0 generate AddUserRoles"
        exit 1
    fi

    echo -e "${YELLOW}Генериране на миграция: $1...${NC}"
    cd db/migrations && npm run migration:create -- src/migrations/$1
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Миграцията е генерирана успешно!${NC}"
    else
        echo -e "${RED}Грешка при генериране на миграцията!${NC}"
        exit 1
    fi
}

# Функция за изпълнение на миграции
run_migrations() {
    echo -e "${YELLOW}Изпълнение на миграции...${NC}"
    cd db/migrations && npm run migration:run
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Миграциите са изпълнени успешно!${NC}"
    else
        echo -e "${RED}Грешка при изпълнение на миграциите!${NC}"
        exit 1
    fi
}

# Функция за връщане на последната миграция
revert_migration() {
    echo -e "${YELLOW}Връщане на последната миграция...${NC}"
    cd db/migrations && npm run migration:revert
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Миграцията е върната успешно!${NC}"
    else
        echo -e "${RED}Грешка при връщане на миграцията!${NC}"
        exit 1
    fi
}

# Функция за връщане на всички миграции
revert_all_migrations() {
    echo -e "${YELLOW}Връщане на всички миграции...${NC}"
    echo -e "${RED}ВНИМАНИЕ: Това ще изтрие всички данни от базата данни!${NC}"
    read -p "Сигурни ли сте? (y/n) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        MIGRATION_COUNT=$(cd db/migrations && npm run migration:show | grep -c "\[X\]")
        for (( i=0; i<$MIGRATION_COUNT; i++ )); do
            cd db/migrations && npm run migration:revert
            if [ $? -ne 0 ]; then
                echo -e "${RED}Грешка при връщане на миграциите!${NC}"
                exit 1
            fi
        done
        echo -e "${GREEN}Всички миграции са върнати успешно!${NC}"
    else
        echo -e "${YELLOW}Операцията е отменена.${NC}"
    fi
}

# Функция за показване на статус на миграциите
show_migration_status() {
    echo -e "${YELLOW}Статус на миграциите:${NC}"
    cd db/migrations && npm run migration:show
}

# Функция за създаване на администраторски потребител
create_admin_user() {
    echo -e "${YELLOW}Създаване на администраторски потребител...${NC}"
    read -p "Имейл: " admin_email
    read -s -p "Парола: " admin_password
    echo
    
    if [ -z "$admin_email" ] || [ -z "$admin_password" ]; then
        echo -e "${RED}Грешка: Имейлът и паролата са задължителни!${NC}"
        exit 1
    fi

    # Тук трябва да се добави логика за хеширане на паролата и вмъкване на потребителя в базата данни
    # За опростяване, ще използваме директна SQL заявка
    
    # Хеширане на паролата (примерно)
    hashed_password=$(echo -n "$admin_password" | shasum -a 256 | awk '{print $1}')
    salt=$(cat /dev/urandom | LC_ALL=C tr -dc 'a-zA-Z0-9' | fold -w 16 | head -n 1)
    
    # Вмъкване на администраторския потребител
    psql -h $DB_HOST -U $DB_USER -d $DB_NAME -c "INSERT INTO users (email, password_hash, salt, role, is_active) VALUES ('$admin_email', '$hashed_password', '$salt', 'admin', true);"
    
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Администраторският потребител е създаден успешно!${NC}"
    else
        echo -e "${RED}Грешка при създаване на администраторския потребител!${NC}"
        exit 1
    fi
}

# Функция за създаване на резервно копие на базата данни
backup_database() {
    echo -e "${YELLOW}Създаване на резервно копие на базата данни...${NC}"
    
    # Създаване на директория за резервни копия, ако не съществува
    mkdir -p db/backups
    
    # Създаване на име на файла с дата и час
    backup_file="db/backups/backup-$(date +%Y-%m-%d_%H-%M-%S).sql"
    
    # Създаване на резервно копие
    pg_dump -h $DB_HOST -U $DB_USER -d $DB_NAME -F p -f "$backup_file"
    
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Резервното копие е създадено успешно: $backup_file${NC}"
    else
        echo -e "${RED}Грешка при създаване на резервното копие!${NC}"
        exit 1
    fi
}

# Функция за възстановяване на базата данни от резервно копие
restore_database() {
    if [ -z "$1" ]; then
        echo -e "${RED}Грешка: Липсва файл за възстановяване${NC}"
        echo "Пример: $0 restore db/backups/backup-2023-05-01.sql"
        exit 1
    fi

    if [ ! -f "$1" ]; then
        echo -e "${RED}Грешка: Файлът не съществува: $1${NC}"
        exit 1
    fi

    echo -e "${YELLOW}Възстановяване на базата данни от резервно копие: $1...${NC}"
    echo -e "${RED}ВНИМАНИЕ: Това ще презапише текущата база данни!${NC}"
    read -p "Сигурни ли сте? (y/n) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        # Изчистване на текущата база данни
        psql -h $DB_HOST -U $DB_USER -d $DB_NAME -c "DROP SCHEMA public CASCADE; CREATE SCHEMA public;"
        
        # Възстановяване от резервно копие
        psql -h $DB_HOST -U $DB_USER -d $DB_NAME -f "$1"
        
        if [ $? -eq 0 ]; then
            echo -e "${GREEN}Базата данни е възстановена успешно!${NC}"
        else
            echo -e "${RED}Грешка при възстановяване на базата данни!${NC}"
            exit 1
        fi
    else
        echo -e "${YELLOW}Операцията е отменена.${NC}"
    fi
}

# Зареждане на променливи от средата
source .env

# Основна логика
case "$1" in
    generate)
        generate_migration "$2"
        ;;
    run)
        run_migrations
        ;;
    revert)
        revert_migration
        ;;
    revert-all)
        revert_all_migrations
        ;;
    status)
        show_migration_status
        ;;
    create-admin)
        create_admin_user
        ;;
    backup)
        backup_database
        ;;
    restore)
        restore_database "$2"
        ;;
    help|*)
        show_help
        ;;
esac

exit 0

db/scripts/run-migrations-tests.sh
#!/bin/bash

# Цветове за терминала
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[0;33m'
NC='\033[0m' # No Color

echo -e "${YELLOW}Стартиране на тестове за миграциите...${NC}"

# Преминаване към директория с миграциите
cd db/migrations

# Изпълнение на тестовете
npm test

# Проверка на резултат
if [ $? -eq 0 ]; then
  echo -e "${GREEN}Тестовете за миграции са успешни!${NC}"
  exit 0
else
  echo -e "${RED}Тестовете за миграции се провалиха!${NC}"
  exit 1
fi

db/scripts/run-docker-tests.sh
#!/bin/bash

# Цветове за терминала
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[0;33m'
NC='\033[0m' # No Color

echo -e "${YELLOW}Стартиране на тестове за миграциите с Docker...${NC}"

# Уверяваме се, че сме в кореновата директория на проекта
cd "$(dirname "$0")/../.."

# Спиране на съществуващи контейнери, които могат да използват порт 5432
docker-compose -f docker-compose.test.yml down

# Стартиране на тестовата база данни
echo -e "${YELLOW}Стартиране на тестова PostgreSQL база данни...${NC}"
docker-compose -f docker-compose.test.yml up -d test-db

# Изчакване базата данни да стане готова
echo -e "${YELLOW}Изчакване базата данни да стане готова...${NC}"
until docker exec $(docker ps -q -f name=test-db) pg_isready -U test_user -h localhost -d test_db; do
  echo "."
  sleep 2
done

echo -e "${GREEN}Базата данни е готова за тестване!${NC}"

# Показване на информация за контейнера
echo -e "${YELLOW}Информация за контейнера:${NC}"
docker ps -f name=test-db

# Изпълнение на тестовете
echo -e "${YELLOW}Изпълнение на тестовете...${NC}"
cd db/migrations
npm test
TEST_RESULT=$?

# Спиране на контейнера
cd ../..
echo -e "${YELLOW}Почистване на ресурсите...${NC}"
docker-compose -f docker-compose.test.yml down

# Връщане на резултата от тестовете
if [ $TEST_RESULT -eq 0 ]; then
  echo -e "${GREEN}Тестовете за миграции са успешни!${NC}"
  exit 0
else
  echo -e "${RED}Тестовете за миграции се провалиха!${NC}"
  exit 1
fi

db/scripts/run-local-tests.sh
#!/bin/bash

# Цветове за терминала
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[0;33m'
NC='\033[0m' # No Color

echo -e "${YELLOW}Стартиране на тестове за миграциите с реалната база данни...${NC}"

# Преминаване към директория с миграциите
cd db/migrations

# Проверка дали PostgreSQL работи
echo -e "${YELLOW}Проверка дали PostgreSQL работи...${NC}"
if docker ps | grep -q learning-platform-db; then
echo -e "${GREEN}PostgreSQL контейнерът е стартиран!${NC}"
else
echo -e "${RED}PostgreSQL контейнерът не е стартиран! Моля, стартирайте го с 'docker-compose up -d db'${NC}"
exit 1
fi

# Изпълнение на тестовете
echo -e "${YELLOW}Изпълнение на тестовете...${NC}"
npm test
TEST_RESULT=$?

# Връщане на резултата от тестовете
if [ $TEST_RESULT -eq 0 ]; then
echo -e "${GREEN}Тестовете за миграции са успешни!${NC}"
exit 0
else
echo -e "${RED}Тестовете за миграции се провалиха!${NC}"
exit 1
fi

db/logs
.eslintrc.js
module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'tsconfig.json',
    tsconfigRootDir: __dirname,
    sourceType: 'module',
  },
  plugins: ['@typescript-eslint/eslint-plugin'],
  extends: [
    'plugin:@typescript-eslint/recommended',
    'plugin:prettier/recommended',
  ],
  root: true,
  env: {
    node: true,
    jest: true,
  },
  ignorePatterns: ['.eslintrc.js'],
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'error',
    'no-console': 'warn',
    'max-len': ['error', { code: 120 }],
    'no-unused-vars': 'off',
    '@typescript-eslint/no-unused-vars': ['error', { argsIgnorePattern: '^_' }],
    'eqeqeq': ['error', 'always'],
    'prefer-const': 'error',
    'no-var': 'error',
    'arrow-parens': ['error', 'always'],
    'object-curly-spacing': ['error', 'always'],
    'quotes': ['error', 'single', { avoidEscape: true }],
    'no-trailing-spaces': 'error',
  },
};

.prettierrc
[Бинарно или не-текстово съдържание не е показано]

docker-compose.test.yml
services:
  # Test database connection
  test-db:
    image: postgres:15
    environment:
      POSTGRES_USER: test_user
      POSTGRES_PASSWORD: test_password
      POSTGRES_DB: test_db
    ports:
      - '5433:5432' # Добавете това
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U test_user -d test_db']
      interval: 5s
      timeout: 5s
      retries: 3
    command: ['postgres', '-c', 'log_statement=all']

  # Test Redis connection
  test-redis:
    image: redis:7-alpine
    command: redis-server --requirepass test_redis_password
    healthcheck:
      test: ['CMD', 'redis-cli', 'ping']
      interval: 5s
      timeout: 5s
      retries: 3


TESTS.md
# Тестове на "Интерактивна онлайн система за самостоятелно обучение"

В този документ ще намерите информация за различните тестове на системата, тяхното предназначение и как да ги изпълнявате.

## Тест на средата за разработка (`validate-docker-infrastructure.ps1`)

### Предназначение

Този скрипт проверява дали локалната среда за разработка е правилно настроена, като тества:

- Наличието на Docker и Docker Compose
- Правилната работа на Docker демона
- Валидността на Docker Compose конфигурацията
- Способността за стартиране и комуникация с PostgreSQL и Redis контейнери
- Основни операции с базата данни и кеша

Скриптът е проектиран да работи както на Windows, така и на Linux системи, използващи PowerShell или PowerShell Core.

### Как да изпълните теста

#### На Windows:

1. Уверете се, че Docker Desktop е стартиран
2. Отворете PowerShell терминал (може да изисква админ права)
3. Разрешете изпълнението на скриптове (по подразбиране Windows има ограничения за сигурност):
   ```powershell
   Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser
   ```
4. Навигирайте до папката на проекта
5. Изпълнете:
   ```powershell
   .\validate-docker-infrastructure..ps1
   ```

#### На Linux (не е тествано дали работи):

1. Инсталирайте PowerShell Core, ако още не е инсталиран:

   ```bash
   # На Debian/Ubuntu
   sudo apt-get update
   sudo apt-get install -y wget apt-transport-https software-properties-common
   wget -q "https://packages.microsoft.com/config/ubuntu/$(lsb_release -rs)/packages-microsoft-prod.deb"
   sudo dpkg -i packages-microsoft-prod.deb
   sudo apt-get update
   sudo apt-get install -y powershell
   ```

2. Направете скрипта изпълним:

   ```bash
   chmod +x validate-docker-infrastructure..ps1
   ```

3. Изпълнете скрипта:
   ```bash
   ./validate-docker-infrastructure..ps1
   # или
   pwsh validate-docker-infrastructure..ps1
   ```

### Очаквани резултати

При успешно изпълнение, тестът ще покаже:

- ✅ Docker е инсталиран
- ✅ Docker Compose е инсталиран
- ✅ Docker работи
- ✅ Docker Compose конфигурацията е валидна
- ✅ Контейнерите са здрави и готови за работа
- ✅ PostgreSQL работи правилно
- ✅ Redis работи правилно
- ✅ Всички тестове преминаха успешно

### Диагностика при грешки

Ако възникне проблем, скриптът ще:

1. Покаже детайлно съобщение за грешка
2. Изведе логове от контейнерите (ако е приложимо)
3. Автоматично почисти тестовите контейнери
4. Предложи възможни решения

### Типични проблеми и решения

| Проблем                       | Решение                                                         |
| ----------------------------- | --------------------------------------------------------------- |
| Docker не работи              | Стартирайте Docker Desktop (Windows) или Docker service (Linux) |
| Грешка при конфигурацията     | Проверете синтаксиса на docker-compose.yml файловете            |
| Контейнерите не стават здрави | Прегледайте логовете за възможни проблеми с мрежата или правата |
| Проблем с PostgreSQL          | Проверете дали порт 5432 не е зает от друго приложение          |
| Проблем с Redis               | Проверете дали порт 6379 не е зает от друго приложение          |

## Тестове на миграциите на базата данни

### Предназначение

Тестовете на миграциите проверяват дали SQL скриптовете за миграция на базата данни работят правилно и могат да бъдат успешно приложени и върнати обратно. Това гарантира, че:

- Всички миграции се изпълняват без грешки
- Схемата на базата данни се създава правилно
- Миграциите могат да бъдат отменени (rolled back) при необходимост
- Индекси и ограничения се създават коректно

Тестовете използват отделна тестова база данни в Docker контейнер, за да не засягат разработката или продукционната среда.

### Налични миграционни тестове

Проектът включва следните миграционни тестове:

1. `CreateInitialSchema1683456789000` - Тества създаването на началната схема с всички таблици и връзки
2. `AddAdditionalIndices1683456789001` - Тества добавянето на допълнителни индекси за оптимизация на заявки

### Как да изпълните тестовете на миграциите

#### Използване на npm:

```bash
# Навигирайте до директорията с миграциите
cd db/migrations

# Изпълнете тестовете
npm test
```

#### Използване на Docker за тестване:

Можете да изпълните тестовете в изолирана Docker среда чрез следния скрипт:

```bash
# От основната директория на проекта
./db/scripts/run-docker-tests.sh
```

### Очаквани резултати

При успешно изпълнение, тестовете ще покажат:

```
PASS  tests/migrations.spec.ts
  Database Migrations
    ✓ should run migrations up successfully
    ✓ should run migrations down successfully
```

Допълнително, ще видите подробен лог на SQL заявките, изпълнени по време на теста.

### Диагностика при грешки

Ако срещнете проблеми с миграционните тестове:

1. **Проблеми с достъпа до тестовата база данни**:

   - Проверете дали тестовият Docker контейнер `test-db` е стартиран
   - Уверете се, че порт 5433 не е зает от друго приложение
   - Проверете дали настройките в `.env.test` са правилни

2. **Синтаксис грешки в SQL**:

   - Прегледайте внимателно логовете за конкретни SQL грешки
   - Коригирайте съответния миграционен файл

3. **Проблеми с PostgreSQL разширения**:
   - Някои миграции може да изискват специфични PostgreSQL разширения
   - Уверете се, че Docker образът включва необходимите разширения или модифицирайте миграциите да използват наличните функционалности (например, използвайте 'simple' вместо специфични езикови конфигурации за текстово търсене)

### Добавяне на нови миграции и тестове

За да добавите нова миграция:

```bash
cd db/migrations
npm run migration:create -- ИмеНаМиграцията
```

### Тест за зареждане на миграции и връзка с базата данни (`db-migration-connection-test.ts`)

#### Предназначение

Този тест фокусира вниманието си върху две ключови функционалности:

1. **Проверка на връзката с базата данни** - Тества дали е възможно да се осъществи успешна връзка с тестовата PostgreSQL база данни
2. **Зареждане на миграционни класове** - Проверява дали TypeORM може правилно да открие и зареди миграционните класове

За разлика от основните тестове на миграциите, този тест НЕ изпълнява самите миграции нагоре или надолу, а само валидира възможността за тяхното откриване и зареждане от TypeORM. Това е полезно за диагностика при проблеми с конфигурацията на TypeORM или с достъпа до базата данни.

#### Как да изпълните теста

```bash
# Навигирайте до директорията с миграциите
cd db/migrations

# Изпълнете теста директно с ts-node
npx ts-node tests/db-migration-connection-test.ts
```

Новата миграция автоматично ще бъде включена в тестовете.

### Използване на специализирания скрипт за тестване (`run-migrations-tests.sh`)

#### Предназначение

Този скрипт осигурява бърз и директен начин за стартиране на тестовете на миграциите без необходимост от допълнителна конфигурация. За разлика от `run-docker-tests.sh`, този скрипт:

- Изпълнява тестовете директно в текущата среда (без Docker)
- Използва съществуващата конфигурация и настройки
- Предоставя прост интерфейс с минимални изисквания за настройка

Скриптът е особено полезен при:

- Бързи проверки на миграциите
- Когато Docker не е наличен или не е необходим
- Интеграция с CI/CD процеси, които контролират собствена среда

#### Как да изпълните скрипта

```bash
# От основната директория на проекта
./db/scripts/run-migrations-tests.sh

# Или от директорията на скриптовете
cd db/scripts
./run-migrations-tests.sh
```

## Unit тестове

_Тази секция ще бъде добавена с напредването на проекта_

## Интеграционни тестове

_Тази секция ще бъде добавена с напредването на проекта_

## End-to-End тестове

_Тази секция ще бъде добавена с напредването на проекта_

## Тестове за сигурност

_Тази секция ще бъде добавена с напредването на проекта_


validate-docker-infrastructure.ps1
#!/usr/bin/env pwsh

# Настройка на цветове
$colorSuccess = "Green"
$colorWarning = "Yellow"
$colorError = "Red"
$colorInfo = "Cyan"

function Show-Message {
  param (
    [string]$Message,
    [string]$ForegroundColor = "White",
    [switch]$NoNewLine
  )
  
  if ($NoNewLine) {
    Write-Host $Message -ForegroundColor $ForegroundColor -NoNewline
  }
  else {
    Write-Host $Message -ForegroundColor $ForegroundColor
  }
}

Show-Message "Стартиране на автоматично тестване и почистване на Docker среда..." $colorInfo

# Проверка за Docker
try {
  $dockerVersion = docker --version
  Show-Message "✅ Docker е инсталиран: $dockerVersion" $colorSuccess
}
catch {
  Show-Message "❌ Docker не е инсталиран или не е достъпен в PATH!" $colorError
  exit 1
}

# Проверка за Docker Compose
try {
  $dockerComposeVersion = docker-compose --version
  Show-Message "✅ Docker Compose е инсталиран: $dockerComposeVersion" $colorSuccess
}
catch {
  Show-Message "❌ Docker Compose не е инсталиран или не е достъпен в PATH!" $colorError
  exit 1
}

# Проверка дали Docker работи
try {
  docker info | Out-Null
  Show-Message "✅ Docker работи" $colorSuccess
}
catch {
  Show-Message "❌ Docker не работи. Моля, стартирайте Docker Desktop." $colorError
  exit 1
}

# Тестване на конфигурацията
Show-Message "Тестване на Docker Compose конфигурацията..." $colorInfo
try {
  docker-compose config | Out-Null
  Show-Message "✅ Docker Compose конфигурацията е валидна" $colorSuccess
}
catch {
  Show-Message "❌ Docker Compose конфигурацията има грешки: $_" $colorError
  exit 1
}

# Пълно почистване на Docker ресурси - без потвърждение
Show-Message "`nЗапочване на пълно почистване на всички Docker ресурси..." $colorWarning

# Спиране на всички контейнери от docker-compose
Show-Message "Стъпка 1: Спиране на контейнери от docker-compose..." $colorInfo
docker-compose down -v
Show-Message "✅ Контейнерите от docker-compose са спрени и томовете са премахнати" $colorSuccess

# Експлицитно почистване на build cache
Show-Message "Стъпка 2: Експлицитно изтриване на Docker Build Cache..." $colorInfo
docker builder prune --force
Show-Message "✅ Build Cache е премахнат" $colorSuccess

# Пълно почистване на всички останали неизползвани ресурси
Show-Message "Стъпка 3: Премахване на всички останали неизползвани Docker ресурси..." $colorInfo
docker system prune -a --volumes --force
Show-Message "✅ Всички неизползвани Docker ресурси са премахнати" $colorSuccess

# Тестване с нови контейнери
Show-Message "`nСтартиране на нови контейнери за тестване..." $colorInfo

# Функция за проверка на контейнерите
function Test-MainContainers {
  param (
    [int]$MaxWaitSeconds = 150,
    [int]$WaitInterval = 2
  )
  
  # Стартиране на контейнерите
  docker-compose up -d
  
  # Динамично изчакване с показване на прогрес
  Show-Message "Изчакване контейнерите да стартират и да станат здрави..." $colorWarning
  
  $totalWaitTime = 0
  $allHealthy = $false
  
  while ($totalWaitTime -lt $MaxWaitSeconds) {
    Show-Message "." $colorWarning -NoNewLine
    
    # Получаване статуса на всички контейнери
    $containersStatus = docker-compose ps --format json | ConvertFrom-Json
    $unhealthyContainers = $containersStatus | Where-Object { $_.State -ne "running" -and $_.State -ne "healthy" }
    
    if (-not $unhealthyContainers) {
      $allHealthy = $true
      break
    }
    
    Start-Sleep -Seconds $WaitInterval
    $totalWaitTime += $WaitInterval
  }
  
  Write-Host ""  # Нов ред след точките
  
  if ($allHealthy) {
    Show-Message "✅ Всички контейнери са стартирани успешно" $colorSuccess
    
    # Показване на детайли за контейнерите
    Show-Message "`nДетайли за контейнерите:" $colorInfo
    docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | Where-Object { $_ -like "*learning-platform*" }
    
    # Тестване на базата данни
    Show-Message "`nТестване на PostgreSQL връзка..." $colorInfo
    $dbContainerName = "learning-platform-db"
    $pgTestResult = docker exec $dbContainerName pg_isready 2>&1
    
    if ($pgTestResult -match "accepting connections") {
      Show-Message "✅ PostgreSQL работи правилно" $colorSuccess
    }
    else {
      Show-Message "❌ Проблем с PostgreSQL: $pgTestResult" $colorError
    }
    
    # Тестване на Redis
    Show-Message "`nТестване на Redis команди..." $colorInfo
    $redisContainerName = "learning-platform-redis"
    $redisTestResult = docker exec $redisContainerName redis-cli ping 2>&1
    
    if ($redisTestResult -match "PONG") {
      Show-Message "✅ Redis работи правилно" $colorSuccess
    }
    else {
      Show-Message "❌ Проблем с Redis: $redisTestResult" $colorError
    }
    
    return $true
  }
  else {
    Show-Message "❌ Не всички контейнери са стартирани успешно в рамките на $MaxWaitSeconds секунди" $colorError
    
    # Показване на логовете, за да видим проблема
    Show-Message "`nЛогове от проблемните контейнери:" $colorInfo
    foreach ($container in $unhealthyContainers) {
      Show-Message "`nЛогове за $($container.Name):" $colorWarning
      docker logs $container.Name --tail 20
    }
    
    return $false
  }
}

# Главна логика за тестване
try {
  $success = Test-MainContainers
  
  if ($success) {
    Show-Message "`n✅ Всички тестове преминаха успешно!" $colorSuccess
    Show-Message "`nНовите контейнери са стартирани и работят правилно" $colorSuccess
    Show-Message "`nСега можете да продължите с разработка използвайки чиста Docker среда." $colorInfo
    exit 0
  }
  else {
    Show-Message "`n❌ Някои тестове не преминаха успешно." $colorError
    
    # Автоматично спиране на контейнерите при неуспех
    Show-Message "Спиране на неуспешните контейнери..." $colorInfo
    docker-compose down
    Show-Message "✅ Контейнерите са спрени" $colorSuccess
    
    Show-Message "`nМоля, проверете грешките и коригирайте конфигурацията преди да стартирате отново." $colorInfo
    exit 1
  }
}
catch {
  Show-Message "❌ Неочаквана грешка при тестване на контейнерите: $_" $colorError
  Show-Message "Спиране на всички контейнери..." $colorInfo
  docker-compose down
  Show-Message "✅ Контейнерите са спрени" $colorSuccess
  exit 1
} 

.env
### Съдържание на .env файл ###
# Database Configuration
DB_USER=postgres
DB_PASSWORD=your_secure_password_here
DB_NAME=learning_platform
DB_PORT=5432

# Redis Configuration
REDIS_PASSWORD=your_redis_password_here
REDIS_PORT=6379

# JWT Configuration
JWT_SECRET=your_jwt_secret_key_here
JWT_EXPIRATION=24h
JWT_REFRESH_EXPIRATION=7d

# Application Configuration
NODE_ENV=development
PORT=3000
LOG_LEVEL=debug

# Email Configuration (за възстановяване на пароли)
SMTP_HOST=smtp.example.com
SMTP_PORT=587
SMTP_USER=your_smtp_user
SMTP_PASSWORD=your_smtp_password
SMTP_FROM=noreply@yourdomain.com

# Frontend Configuration
REACT_APP_API_URL=http://localhost:8080
REACT_APP_ENV=development

# Security
RATE_LIMIT_MAX=100
RATE_LIMIT_WINDOW_MS=900000

# File Upload
MAX_FILE_SIZE=5242880
### Край на .env файл ###

docker-compose.yml
services:
  # PostgreSQL база данни
  db:
    image: postgres:15
    container_name: learning-platform-db
    environment:
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_DB: ${DB_NAME}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./db/init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - '5433:5432'
    networks:
      - learning-network
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U ${DB_USER} -d ${DB_NAME}']
      interval: 10s
      timeout: 5s
      retries: 5

  # Redis кеш
  redis:
    image: redis:7-alpine
    container_name: learning-platform-redis
    command: redis-server --requirepass ${REDIS_PASSWORD}
    volumes:
      - redis_data:/data
    ports:
      - '6379:6379'
    networks:
      - learning-network
    healthcheck:
      test: ['CMD', 'redis-cli', 'ping']
      interval: 10s
      timeout: 5s
      retries: 5

  # Auth Service
  auth-service:
    build:
      context: ./services/auth
      dockerfile: Dockerfile
    container_name: learning-platform-auth
    environment:
      NODE_ENV: development
      DATABASE_URL: postgres://${DB_USER}:${DB_PASSWORD}@db:5433/${DB_NAME}
      REDIS_URL: redis://:${REDIS_PASSWORD}@redis:6379
      JWT_SECRET: ${JWT_SECRET}
    ports:
      - '3001:3000'
    networks:
      - learning-network
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    volumes:
      - ./services/auth:/app
      - /app/node_modules
    command: npm run start:dev

  # User Service
  user-service:
    build:
      context: ./services/user
      dockerfile: Dockerfile
    container_name: learning-platform-user
    environment:
      NODE_ENV: development
      DATABASE_URL: postgres://${DB_USER}:${DB_PASSWORD}@db:5433/${DB_NAME}
      REDIS_URL: redis://:${REDIS_PASSWORD}@redis:6379
      JWT_SECRET: ${JWT_SECRET}
    ports:
      - '3002:3000'
    networks:
      - learning-network
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    volumes:
      - ./services/user:/app
      - /app/node_modules
    command: npm run start:dev

  # Course Service
  course-service:
    build:
      context: ./services/course
      dockerfile: Dockerfile
    container_name: learning-platform-course
    environment:
      NODE_ENV: development
      DATABASE_URL: postgres://${DB_USER}:${DB_PASSWORD}@db:5433/${DB_NAME}
      REDIS_URL: redis://:${REDIS_PASSWORD}@redis:6379
      JWT_SECRET: ${JWT_SECRET}
    ports:
      - '3003:3000'
    networks:
      - learning-network
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    volumes:
      - ./services/course:/app
      - /app/node_modules
    command: npm run start:dev

  # Test Service
  test-service:
    build:
      context: ./services/test
      dockerfile: Dockerfile
    container_name: learning-platform-test
    environment:
      NODE_ENV: development
      DATABASE_URL: postgres://${DB_USER}:${DB_PASSWORD}@db:5433/${DB_NAME}
      REDIS_URL: redis://:${REDIS_PASSWORD}@redis:6379
      JWT_SECRET: ${JWT_SECRET}
    ports:
      - '3004:3000'
    networks:
      - learning-network
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    volumes:
      - ./services/test:/app
      - /app/node_modules
    command: npm run start:dev

  # Analytics Service
  analytics-service:
    build:
      context: ./services/analytics
      dockerfile: Dockerfile
    container_name: learning-platform-analytics
    environment:
      NODE_ENV: development
      DATABASE_URL: postgres://${DB_USER}:${DB_PASSWORD}@db:5433/${DB_NAME}
      REDIS_URL: redis://:${REDIS_PASSWORD}@redis:6379
      JWT_SECRET: ${JWT_SECRET}
    ports:
      - '3005:3000'
    networks:
      - learning-network
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    volumes:
      - ./services/analytics:/app
      - /app/node_modules
    command: npm run start:dev

  # Ads Service
  ads-service:
    build:
      context: ./services/ads
      dockerfile: Dockerfile
    container_name: learning-platform-ads
    environment:
      NODE_ENV: development
      DATABASE_URL: postgres://${DB_USER}:${DB_PASSWORD}@db:5433/${DB_NAME}
      REDIS_URL: redis://:${REDIS_PASSWORD}@redis:6379
      JWT_SECRET: ${JWT_SECRET}
    ports:
      - '3006:3000'
    networks:
      - learning-network
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    volumes:
      - ./services/ads:/app
      - /app/node_modules
    command: npm run start:dev

  # Frontend
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: learning-platform-frontend
    environment:
      NODE_ENV: development
      REACT_APP_API_URL: http://nginx:8080
    ports:
      - '3000:3000'
    networks:
      - learning-network
    volumes:
      - ./frontend:/app
      - /app/node_modules
    command: npm start

  # Nginx Gateway
  nginx:
    build:
      context: ./nginx
      dockerfile: Dockerfile
    container_name: learning-platform-nginx
    ports:
      - '8080:80'
    networks:
      - learning-network
    depends_on:
      - auth-service
      - user-service
      - course-service
      - test-service
      - analytics-service
      - ads-service
      - frontend
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro

networks:
  learning-network:
    driver: bridge

volumes:
  postgres_data:
  redis_data:


redis
redis/logs
