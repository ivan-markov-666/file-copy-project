src\auth\auth.module.ts:
import { Module, forwardRef } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { JwtStrategy } from './jwt.strategy';
import { PassportModule } from '@nestjs/passport';
import { AuthService } from './auth.service';
import { UserModule } from '../user/user.module'; 
import { JwtAuthGuard } from './jwt-auth.guard';

@Module({
  imports: [
    PassportModule,
    JwtModule.registerAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: (configService: ConfigService) => ({
        secret: configService.get('JWT_SECRET'),
        signOptions: { expiresIn: '1h' },
      }),
    }),
    forwardRef(() => UserModule), 
  ],
  providers: [AuthService, JwtStrategy, JwtAuthGuard],
  exports: [AuthService, JwtAuthGuard, JwtModule],
})
export class AuthModule {}



src\auth\auth.service.ts:
import { Injectable, Inject, forwardRef } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { UserService } from '../user/user.service';
import { RabbitMQProvider } from '../common/providers/rabbitmq.provider';

@Injectable()
export class AuthService {
  constructor(
    private readonly jwtService: JwtService,
    @Inject(forwardRef(() => UserService)) 
    private readonly userService: UserService,
    private readonly rabbitMQProvider: RabbitMQProvider, 
  ) {}

  async validateUser(username: string, password: string) {
    const user = await this.userService.getUserByUsername(username);
    if (user && user.password === password) {
      return user;
    }
    return null;
  }

  async login(user: any) {
    const payload = { username: user.username, sub: user.id };
    const token = this.jwtService.sign(payload);

    
    await this.rabbitMQProvider.sendMessage('user_logged_in', {
      userId: user.id,
      username: user.username,
      timestamp: new Date().toISOString(),
    });

    return { access_token: token };
  }
}



src\auth\jwt-auth.guard.ts:

import { Injectable, CanActivate, ExecutionContext, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';

@Injectable()
export class JwtAuthGuard implements CanActivate {
  constructor(private readonly jwtService: JwtService) {}

  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest();
    const authHeader = request.headers['authorization'];

    if (!authHeader) {
      throw new UnauthorizedException('Authorization header is missing');
    }

    const token = authHeader.split(' ')[1];
    try {
      const payload = this.jwtService.verify(token);
      request.user = payload;
      return true;
    } catch (error) {
      throw new UnauthorizedException(`Invalid or expired token. Received error: ${error}`);
    }
  }
}



src\auth\jwt.strategy.ts:
import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(configService: ConfigService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: configService.get('JWT_SECRET'),
    });
  }

  async validate(payload: any) {
    return { userId: payload.sub, username: payload.username };
  }
}



src\common\config\elasticsearch.config.ts:


import { Client } from '@elastic/elasticsearch';
import { ConfigService } from '@nestjs/config';
import { readFileSync } from 'fs';


export const createElasticsearchClient = (configService: ConfigService): Client => {
  try {
    
    const caCertPath = configService.get<string>('ELASTICSEARCH_CA_CERT'); 
    const username = configService.get<string>('ELASTICSEARCH_USERNAME'); 
    const password = configService.get<string>('ELASTICSEARCH_PASSWORD'); 
    const node = configService.get<string>('ELASTICSEARCH_NODE'); 

    
    if (!caCertPath || !username || !password || !node) {
      throw new Error(
        `❌ Missing required Elasticsearch configuration values: ${!caCertPath ? 'ELASTICSEARCH_CA_CERT ' : ''}${!username ? 'ELASTICSEARCH_USERNAME ' : ''}${
          !password ? 'ELASTICSEARCH_PASSWORD ' : ''
        }${!node ? 'ELASTICSEARCH_NODE ' : ''}. Please check your .env file.`,
      );
    }

    
    return new Client({
      node, 
      auth: { username, password }, 
      tls: {
        ca: caCertPath ? readFileSync(caCertPath) : undefined, 
        rejectUnauthorized: true, 
      },
    });
  } catch (error) {
    console.error('❌ Elasticsearch configuration error:', error.message);
    throw new Error('Failed to configure Elasticsearch client.');
  }
};



src\common\config\redis.config.ts:


import { ConfigService } from '@nestjs/config';


interface RedisConfig {
  host: string;
  port: number;
  password?: string;
}


export const getRedisConfig = (configService: ConfigService): RedisConfig => {
  
  const REDIS_HOST = configService.get<string>('REDIS_HOST');
  const REDIS_PORT = Number(configService.get<number>('REDIS_PORT') ?? 6379); 
  const REDIS_PASSWORD = configService.get<string>('REDIS_PASSWORD') ?? null; 

  
  if (!REDIS_HOST) {
    throw new Error(`❌ Missing Redis configuration: REDIS_HOST is not set. Check your .env file.`);
  }

  
  if (!Number.isInteger(REDIS_PORT) || REDIS_PORT <= 0) {
    throw new Error(`❌ Invalid Redis configuration: REDIS_PORT=${REDIS_PORT}. It must be a positive integer.`);
  }

  
  return {
    host: REDIS_HOST,
    port: REDIS_PORT,
    password: REDIS_PASSWORD?.trim()?.length ? REDIS_PASSWORD : undefined, 
  };
};



src\common\config\validation.schema.ts:


import * as Joi from 'joi';


export const configValidationSchema = Joi.object({
  
  USER_SERVICE_PORT: Joi.number().default(3001), 

  
  DATABASE_HOST: Joi.string().required(), 
  DATABASE_PORT: Joi.number().default(5432), 
  DATABASE_USER: Joi.string().required(), 
  DATABASE_PASSWORD: Joi.string().required(), 
  DATABASE_NAME: Joi.string().required(), 

  
  REDIS_HOST: Joi.string().required(), 
  REDIS_PORT: Joi.number().default(6379), 
  REDIS_PASSWORD: Joi.string().allow(''), 

  
  JWT_SECRET: Joi.string().required(), 

  
  RABBITMQ_DEFAULT_USER: Joi.string().required(), 
  RABBITMQ_DEFAULT_PASS: Joi.string().required(), 

  
  ELASTIC_PASSWORD: Joi.string().required(), 
  KIBANA_PASSWORD: Joi.string().required(), 

  
  STACK_VERSION: Joi.string().default('8.17.1'), 
  CLUSTER_NAME: Joi.string().default('docker-cluster'), 

  
  LICENSE: Joi.string().valid('basic', 'trial').default('basic'), 

  
  ES_PORT: Joi.number().default(9200), 
  KIBANA_PORT: Joi.number().default(5601), 

  
  MEM_LIMIT: Joi.number().positive().default(1073741824), 

  
  ELASTICSEARCH_NODE: Joi.string().uri().required(), 
  ELASTICSEARCH_USERNAME: Joi.string().required(), 
  ELASTICSEARCH_PASSWORD: Joi.string().required(), 
  ELASTICSEARCH_CA_CERT: Joi.string().required(), 
});



src\common\controllers\dlq.controller.ts:
import { Controller, Post, Get, Body, Param, Query, Logger, ValidationPipe, UsePipes, UseGuards, HttpStatus, HttpCode, BadRequestException, InternalServerErrorException } from '@nestjs/common';
import { RabbitMQProvider } from '../providers/rabbitmq.provider';
import { IsString, IsNotEmpty, IsNumber, IsOptional, Min, Max } from 'class-validator';
import { ApiTags, ApiOperation, ApiResponse, ApiBody, ApiParam, ApiQuery } from '@nestjs/swagger';
import { InjectMetric } from '@willsoto/nestjs-prometheus';
import { Counter, Gauge } from 'prom-client';
import { JwtAuthGuard } from '../../auth/jwt-auth.guard'; 
import { Roles } from '../decorators/roles.decorator';
import { RolesGuard } from '../guards/roles.guard';


enum QueueType {
  USER = 'user_dlq',
  PAYMENT = 'payment_dlq',
  ORDER = 'order_dlq',
}


class RetryMessageDto {
  @IsString()
  @IsNotEmpty({ message: 'Message cannot be empty' })
  message: string;

  @IsOptional()
  @IsNumber()
  @Min(1)
  @Max(10)
  priority?: number = 5;
}


class RetryResponseDto {
  success: boolean;
  message: string;
}


class DLQMessagesResponseDto {
  success: boolean;
  messages: any[];
  count: number;
}

@ApiTags('Dead Letter Queue')
@Controller('dlq')
@UseGuards(JwtAuthGuard, RolesGuard)
export class DLQController {
  private readonly logger = new Logger(DLQController.name);

  constructor(
    private readonly rabbitMQProvider: RabbitMQProvider,
    @InjectMetric('dlq_retry_attempts_total')
    private readonly dlqRetryCounter: Counter<string>,
    @InjectMetric('dlq_retry_success_total')
    private readonly dlqRetrySuccessCounter: Counter<string>,
    @InjectMetric('dlq_message_count_gauge')
    private readonly dlqMessageCountGauge: Gauge<string>,
  ) {}

  @Get()
  @Roles('admin', 'support')
  @ApiOperation({ summary: 'List messages in DLQ' })
  @ApiQuery({ name: 'queue', enum: QueueType, required: false, description: 'Queue name' })
  @ApiQuery({ name: 'limit', type: Number, required: false, description: 'Maximum number of messages to return' })
  @ApiQuery({ name: 'filter', type: String, required: false, description: 'Filter messages by content' })
  @ApiResponse({ status: HttpStatus.OK, description: 'List of DLQ messages', type: DLQMessagesResponseDto })
  @ApiResponse({ status: HttpStatus.INTERNAL_SERVER_ERROR, description: 'Error listing DLQ messages' })
  async listDLQMessages(@Query('queue') queue: QueueType = QueueType.USER, @Query('limit') limit: number = 20, @Query('filter') filter?: string): Promise<DLQMessagesResponseDto> {
    try {
      this.logger.log(`Getting messages from ${queue} (limit: ${limit}, filter: ${filter || 'none'})`);

      const messages = await this.rabbitMQProvider.listDLQMessages(queue, limit, filter);

      
      this.dlqMessageCountGauge.set({ queue }, messages.length);

      return {
        success: true,
        messages,
        count: messages.length,
      };
    } catch (error) {
      this.logger.error(`❌ Error listing DLQ messages: ${error.message}`);
      throw new InternalServerErrorException(`Failed to list DLQ messages: ${error.message}`);
    }
  }

  @Get('stats')
  @Roles('admin', 'support')
  @ApiOperation({ summary: 'Get DLQ statistics' })
  @ApiResponse({ status: HttpStatus.OK, description: 'DLQ statistics' })
  async getDLQStats() {
    try {
      const stats = await this.rabbitMQProvider.getDLQStats();
      return { success: true, stats };
    } catch (error) {
      this.logger.error(`❌ Error getting DLQ stats: ${error.message}`);
      throw new InternalServerErrorException(`Failed to get DLQ stats: ${error.message}`);
    }
  }

  @Post('retry')
  @HttpCode(HttpStatus.OK)
  @Roles('admin')
  @ApiOperation({ summary: 'Retry a message from default DLQ' })
  @ApiBody({ type: RetryMessageDto })
  @ApiResponse({ status: HttpStatus.OK, description: 'Message was successfully retried', type: RetryResponseDto })
  @ApiResponse({ status: HttpStatus.BAD_REQUEST, description: 'Invalid message format' })
  @ApiResponse({ status: HttpStatus.INTERNAL_SERVER_ERROR, description: 'Error retrying message' })
  @UsePipes(new ValidationPipe({ transform: true }))
  async retryMessage(@Body() body: RetryMessageDto): Promise<RetryResponseDto> {
    return this.retryMessageFromQueue(QueueType.USER, body);
  }

  @Post('retry/:queueName')
  @HttpCode(HttpStatus.OK)
  @Roles('admin')
  @ApiOperation({ summary: 'Retry a message from specific DLQ' })
  @ApiParam({ name: 'queueName', enum: QueueType })
  @ApiBody({ type: RetryMessageDto })
  @ApiResponse({ status: HttpStatus.OK, description: 'Message was successfully retried', type: RetryResponseDto })
  @ApiResponse({ status: HttpStatus.BAD_REQUEST, description: 'Invalid queue or message format' })
  @ApiResponse({ status: HttpStatus.INTERNAL_SERVER_ERROR, description: 'Error retrying message' })
  @UsePipes(new ValidationPipe({ transform: true }))
  async retryMessageFromQueue(@Param('queueName') queueName: QueueType = QueueType.USER, @Body() body: RetryMessageDto): Promise<RetryResponseDto> {
    try {
      if (!Object.values(QueueType).includes(queueName as QueueType)) {
        throw new BadRequestException(`Invalid queue name. Must be one of: ${Object.values(QueueType).join(', ')}`);
      }

      this.logger.log(`Attempting to retry message from ${queueName}`);

      
      this.dlqRetryCounter.inc({ queue: queueName });

      
      await this.rabbitMQProvider.retryMessage(queueName, {
        content: Buffer.from(body.message),
        fields: {
          deliveryTag: 0,
          redelivered: false,
          exchange: '',
          routingKey: '',
        },
        properties: {
          headers: {},
          priority: body.priority || 5,
        },
      });

      
      this.dlqRetrySuccessCounter.inc({ queue: queueName });

      this.logger.log(`✅ Successfully retried message from ${queueName}`);
      return { success: true, message: `Message from ${queueName} retried successfully` };
    } catch (error) {
      this.logger.error(`❌ Error retrying message from ${queueName}: ${error.message}`);
      throw new BadRequestException(`Failed to retry message: ${error.message}`);
    }
  }

  @Post('retry-all/:queueName')
  @HttpCode(HttpStatus.OK)
  @Roles('admin')
  @ApiOperation({ summary: 'Retry all messages from specific DLQ' })
  @ApiParam({ name: 'queueName', enum: QueueType })
  @ApiQuery({ name: 'batchSize', type: Number, required: false, description: 'Number of messages to process in each batch' })
  @ApiResponse({ status: HttpStatus.OK, description: 'Messages queued for retry', type: RetryResponseDto })
  @ApiResponse({ status: HttpStatus.BAD_REQUEST, description: 'Invalid queue' })
  @ApiResponse({ status: HttpStatus.INTERNAL_SERVER_ERROR, description: 'Error retrying messages' })
  async retryAllMessages(@Param('queueName') queueName: QueueType, @Query('batchSize') batchSize: number = 10): Promise<RetryResponseDto> {
    try {
      if (!Object.values(QueueType).includes(queueName as QueueType)) {
        throw new BadRequestException(`Invalid queue name. Must be one of: ${Object.values(QueueType).join(', ')}`);
      }

      this.logger.log(`Attempting to retry all messages from ${queueName} with batch size ${batchSize}`);

      
      const count = await this.rabbitMQProvider.retryAllMessages(queueName, batchSize);

      if (count === 0) {
        return { success: true, message: `No messages found in ${queueName} to retry` };
      }

      return {
        success: true,
        message: `${count} messages from ${queueName} queued for retry`,
      };
    } catch (error) {
      this.logger.error(`❌ Error retrying all messages from ${queueName}: ${error.message}`);
      throw new InternalServerErrorException(`Failed to retry all messages: ${error.message}`);
    }
  }

  @Post('purge/:queueName')
  @HttpCode(HttpStatus.OK)
  @Roles('admin')
  @ApiOperation({ summary: 'Purge all messages from specific DLQ' })
  @ApiParam({ name: 'queueName', enum: QueueType })
  @ApiResponse({ status: HttpStatus.OK, description: 'Queue purged successfully', type: RetryResponseDto })
  @ApiResponse({ status: HttpStatus.BAD_REQUEST, description: 'Invalid queue' })
  @ApiResponse({ status: HttpStatus.INTERNAL_SERVER_ERROR, description: 'Error purging queue' })
  async purgeQueue(@Param('queueName') queueName: QueueType): Promise<RetryResponseDto> {
    try {
      if (!Object.values(QueueType).includes(queueName as QueueType)) {
        throw new BadRequestException(`Invalid queue name. Must be one of: ${Object.values(QueueType).join(', ')}`);
      }

      this.logger.log(`Purging queue ${queueName}`);

      const count = await this.rabbitMQProvider.purgeQueue(queueName);

      
      this.dlqMessageCountGauge.set({ queue: queueName }, 0);

      return {
        success: true,
        message: `Successfully purged ${count} messages from ${queueName}`,
      };
    } catch (error) {
      this.logger.error(`❌ Error purging queue ${queueName}: ${error.message}`);
      throw new InternalServerErrorException(`Failed to purge queue: ${error.message}`);
    }
  }
}



src\common\controllers\elasticsearch-test.controller.ts:
import { Controller, Get } from '@nestjs/common';
import { LoggingService } from '../services/logging.service';

@Controller('elasticsearch-test')
export class ElasticsearchTestController {
  constructor(private readonly loggingService: LoggingService) {}

  @Get('send-logs')
  async sendTestLogs() {
    
    await this.loggingService.log('This is a test log message', 'TestContext');
    await this.loggingService.error('This is a test error message', 'Error stack trace', 'ErrorContext');
    await this.loggingService.warn('This is a test warning message', 'WarningContext');

    return { message: 'Test logs sent to Elasticsearch' };
  }
}



src\common\controllers\interceptorTest.controller.ts:
import { Controller, Post } from '@nestjs/common';

@Controller('test')
export class InterceptorTestController {
  @Post('interceptor-test')
  testInterceptor() {
    return { message: 'Interceptor test successful' };
  }
}



src\common\decorators\roles.decorator.ts:
import { SetMetadata } from '@nestjs/common';

export const ROLES_KEY = 'roles';
export const Roles = (...roles: string[]) => SetMetadata(ROLES_KEY, roles);



src\common\filters\global-exception.filter.ts:
import { ArgumentsHost, Catch, ExceptionFilter, HttpException, HttpStatus } from '@nestjs/common';
import { RpcException } from '@nestjs/microservices';
import { LoggingService } from '../services/logging.service';

@Catch()
export class GlobalExceptionFilter implements ExceptionFilter {
  constructor(private readonly loggingService: LoggingService) {}

  catch(exception: unknown, host: ArgumentsHost) {
    const ctxType = host.getType();
    const timestamp = new Date().toISOString();

    if (ctxType === 'http') {
      this.handleHttpException(exception, host, timestamp);
    } else if (ctxType === 'rpc') {
      this.handleRpcException(exception, host, timestamp);
    } else {
      this.handleGenericException(exception, host, timestamp);
    }
  }

  private handleHttpException(exception: unknown, host: ArgumentsHost, timestamp: string) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse();
    const request = ctx.getRequest();

    const status = exception instanceof HttpException ? exception.getStatus() : HttpStatus.INTERNAL_SERVER_ERROR;

    const errorResponse = {
      statusCode: status,
      timestamp,
      path: request.url,
      message: exception instanceof HttpException ? exception.message : 'Internal server error',
    };

    this.loggingService.error(`HTTP Exception: ${JSON.stringify(errorResponse)}`, exception instanceof Error ? exception.stack : undefined);

    response.status(status).json(errorResponse);
  }

  private handleRpcException(exception: unknown, host: ArgumentsHost, timestamp: string) {
    const ctx = host.switchToRpc();
    const data = ctx.getData();

    const errorResponse = {
      status: 'error',
      timestamp,
      message: exception instanceof RpcException ? exception.message : 'Internal server error',
      data: data || null,
    };

    this.loggingService.error(`RPC Exception: ${JSON.stringify(errorResponse)}`, exception instanceof Error ? exception.stack : undefined);

    return errorResponse;
  }

  private handleGenericException(
    exception: unknown,
    host: ArgumentsHost,
    
    timestamp: string,
  ) {
    const contextType = host.getType();
    const message = `Unhandled exception in context: ${contextType}`;
    this.loggingService.error(`${message}: ${exception instanceof Error ? exception.message : exception}`, exception instanceof Error ? exception.stack : undefined);

    
    
    
    if ((contextType as string) === 'custom') {
      
    } else {
      
      this.loggingService.warn(`Unknown context type: ${contextType}`);
    }
  }
}



src\common\filters\rpc-exception.filter.ts:
import { ArgumentsHost, Catch, ExceptionFilter } from '@nestjs/common';
import { RpcException } from '@nestjs/microservices';
import { LoggingService } from '../services/logging.service';

@Catch()
export class RpcExceptionFilter implements ExceptionFilter {
  constructor(private readonly loggingService: LoggingService) {}
  catch(exception: RpcException, host: ArgumentsHost) {
    const ctx = host.switchToRpc();
    const data = ctx.getData();

    const errorResponse = {
      status: 'error',
      message: exception.message || 'Internal server error',
      data: data || null,
    };

    
    this.loggingService.error('RPC Exception', JSON.stringify(errorResponse));

    return errorResponse;
  }
}



src\common\guards\roles.guard.ts:
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { ROLES_KEY } from '../decorators/roles.decorator';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.getAllAndOverride<string[]>(ROLES_KEY, [context.getHandler(), context.getClass()]);

    if (!requiredRoles) {
      return true;
    }

    const { user } = context.switchToHttp().getRequest();
    return requiredRoles.some((role) => user.roles?.includes(role));
  }
}



src\common\interceptors\logging.interceptor.ts:
import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { Observable } from 'rxjs';
import { LoggingService } from '../services/logging.service';
import { tap } from 'rxjs/operators';

@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  constructor(private readonly loggingService: LoggingService) {}

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const ctxType = context.getType();
    const timestamp = new Date().toISOString();

    if (ctxType === 'http') {
      const request = context.switchToHttp().getRequest();
      const method = request.method;
      const url = request.url;

      this.loggingService.log(`Request: ${method} ${url} at ${timestamp}`);
    } else if (ctxType === 'rpc') {
      const rpcData = context.switchToRpc().getData();
      this.loggingService.log(`RPC Request: ${JSON.stringify(rpcData)} at ${timestamp}`);
    }

    return next.handle().pipe(
      tap((response) => {
        this.loggingService.log(`Response: ${JSON.stringify(response)} at ${timestamp}`);
      }),
    );
  }
}



src\common\metrics\metrics.module.ts:
import { Module } from '@nestjs/common';
import { makeHistogramProvider, makeCounterProvider, PrometheusModule } from '@willsoto/nestjs-prometheus';

@Module({
  imports: [
    PrometheusModule.register({
      defaultMetrics: {
        enabled: true, 
      },
    }),
  ],
  providers: [
    makeCounterProvider({
      name: 'PROM_METRIC_USER_REGISTERED_TOTAL',
      help: 'Total number of registered users',
    }),
    makeHistogramProvider({
      name: 'PROM_METRIC_USER_REQUEST_DURATION_SECONDS',
      help: 'Duration of user requests in seconds',
      buckets: [0.1, 0.5, 1, 2, 5],
    }),
  ],
  exports: [
    PrometheusModule,
    makeCounterProvider({
      name: 'PROM_METRIC_USER_REGISTERED_TOTAL',
      help: 'Total number of registered users',
    }),
    makeHistogramProvider({
      name: 'PROM_METRIC_USER_REQUEST_DURATION_SECONDS',
      help: 'Duration of user requests in seconds',
      buckets: [0.1, 0.5, 1, 2, 5],
    }),
  ],
})
export class MetricsModule {}



src\common\providers\rabbitmq.provider.ts:
import { Injectable, OnModuleInit, Logger, OnModuleDestroy } from '@nestjs/common';
import * as amqp from 'amqplib';
import { LoggingService } from '../services/logging.service';
import { InjectMetric } from '@willsoto/nestjs-prometheus';
import { Counter, Gauge } from 'prom-client';
import * as CircuitBreaker from 'opossum';

@Injectable()
export class RabbitMQProvider implements OnModuleInit, OnModuleDestroy {
  private connection: amqp.Connection | null = null;
  private channel: amqp.Channel | null = null;
  private readonly logger = new Logger(RabbitMQProvider.name);
  private isRabbitAvailable = false; 
  private readonly retryDelay = 5000;

  
  private sendMessageBreaker: CircuitBreaker<[string, any, number], void>;

  constructor(
    private readonly loggingService: LoggingService,
    @InjectMetric('dlq_message_count')
    private readonly dlqMessageCount: Counter<string>,
    @InjectMetric('dlq_message_age_seconds')
    private readonly dlqMessageAge: Gauge<string>,
  ) {
    this.initCircuitBreaker();
  }

  async onModuleInit() {
    await this.connectRabbitMQ();
    
  }

  async onApplicationShutdown() {
    this.logger.warn('⚠️ Application is shutting down. Closing RabbitMQ connection...');
    if (this.channel) {
      await this.channel.close();
      this.logger.log('🔌 RabbitMQ Channel closed.');
    }
    if (this.connection) {
      await this.connection.close();
      this.logger.log('🔌 RabbitMQ Connection closed.');
    }
  }

  private initCircuitBreaker() {
    this.sendMessageBreaker = new CircuitBreaker(
      async (queue: string, message: any, priority: number) => {
        await this.sendMessageInternal(queue, message, priority);
      },
      {
        timeout: 5000, 
        errorThresholdPercentage: 50, 
        resetTimeout: 30000, 
      },
    );
    this.sendMessageBreaker.on('open', () => {
      this.logger.warn('⚠️ Circuit Breaker is OPEN! RabbitMQ може да е недостъпен.');
    });

    this.sendMessageBreaker.on('close', () => {
      this.logger.log('✅ Circuit Breaker е затворен. RabbitMQ работи нормално.');
    });

    this.sendMessageBreaker.on('halfOpen', () => {
      this.logger.log('🔄 Circuit Breaker е в HALF-OPEN режим. Пробваме отново...');
    });

    this.sendMessageBreaker.on('fallback', (args) => {
      this.logger.error(`❌ Circuit Breaker fallback! Не можахме да изпратим съобщение до ${args[0]}`);
    });

    
    this.sendMessageBreaker.fallback(async (queue, message, priority) => {
      try {
        this.logger.warn(`⚠️ Circuit Breaker блокира! Изпращам в DLQ: ${queue}`);

        await this.sendMessageInternal('user_dlq', message, priority);
      } catch (error) {
        this.logger.error(`❌ Грешка при изпращане в DLQ: ${error.message}`);
      }
    });
  }

  async connectRabbitMQ() {
    try {
      this.logger.log('🔄 Опит за свързване с RabbitMQ...');

      this.connection = await amqp.connect('amqp://rabbitMQAdmin:rabbitMQAdminPassword@localhost:5672');
      this.channel = await this.connection.createChannel();
      await this.channel.prefetch(5);

      this.isRabbitAvailable = true; 
      this.logger.log('✅ RabbitMQ свързан успешно!');

      
      this.connection.on('error', (err) => {
        this.logger.error(`❌ Грешка в RabbitMQ връзката: ${err.message}`);
        this.isRabbitAvailable = false; 
        this.reconnect();
      });

      
      this.connection.on('close', () => {
        this.logger.warn('⚠️ RabbitMQ връзката се затвори. Пробвам да я възстановя...');
        this.isRabbitAvailable = false;
        this.reconnect();
      });

      
      await this.setupQueues();
    } catch (error) {
      this.isRabbitAvailable = false; 
      this.logger.warn(`⚠️ Неуспешно свързване с RabbitMQ: ${error.message}`);

      
      setTimeout(() => this.connectRabbitMQ(), this.retryDelay);
    }
  }

  async processDLQ() {
    const dlqQueues = ['user_dlq', 'payment_dlq', 'order_dlq'];

    for (const queue of dlqQueues) {
      try {
        const { messageCount } = await this.channel.checkQueue(queue);
        if (messageCount > 0) {
          this.logger.warn(`⚠️ DLQ (${queue}) има ${messageCount} съобщения!`);
          await this.consumeDLQ(queue);
        }
      } catch (error) {
        this.logger.error(`❌ Грешка при проверка на DLQ (${queue}): ${error.message}`);
      }
    }
  }

  private startDLQMonitor() {
    setInterval(() => this.processDLQ(), 60000);
  }

  private reconnecting = false; 

  private reconnectInterval: NodeJS.Timeout | null = null;

  async reconnect() {
    if (this.reconnecting || this.reconnectInterval) return;

    this.reconnecting = true;
    this.logger.warn('⚠️ Lost connection to RabbitMQ. Attempting reconnection...');

    this.reconnectInterval = setInterval(async () => {
      try {
        await this.connectRabbitMQ();
        this.logger.log('✅ RabbitMQ connection restored!');
        clearInterval(this.reconnectInterval);
        this.reconnectInterval = null;
        this.reconnecting = false;
      } catch (error) {
        this.logger.warn(`🔄 RabbitMQ is still unreachable. Retrying in 120 seconds... Error: ${error.message}`);
      }
    }, 120000);
  }

  async setupQueues() {
    await this.channel.assertExchange('dlx_exchange', 'direct', {
      durable: true,
    });
    await this.channel.assertExchange('retry_exchange', 'direct', {
      durable: true,
    });

    const dlqQueues = ['user_dlq', 'payment_dlq', 'order_dlq'];
    for (const queue of dlqQueues) {
      await this.channel.assertQueue(queue, {
        durable: true,
        arguments: { 'x-dead-letter-exchange': 'retry_exchange' },
      });
      await this.channel.bindQueue(queue, 'dlx_exchange', queue);
    }

    await this.channel.assertQueue('retry_queue', {
      durable: true,
      arguments: {
        'x-dead-letter-exchange': 'main_exchange',
        'x-max-priority': 10,
      },
    });

    await this.channel.bindQueue('retry_queue', 'retry_exchange', 'retry_routing_key');
    this.logger.log('✅ RabbitMQ DLQ & Retry конфигурирани успешно!');
  }

  async sendMessage(queue: string, message: any) {
    if (!this.isRabbitAvailable || !this.channel) {
      this.logger.warn(`⚠️ Не можахме да изпратим съобщение до ${queue}. RabbitMQ не е наличен.`);
      return;
    }

    try {
      await this.channel.sendToQueue(queue, Buffer.from(JSON.stringify(message)), { persistent: true });
      this.logger.log(`📩 Съобщението до ${queue} беше изпратено успешно.`);
    } catch (error) {
      this.logger.error(`❌ Грешка при изпращане към RabbitMQ: ${error.message}`);
    }
  }

  private async sendMessageInternal(queue: string, message: any, priority = 5) {
    let attempts = 0;
    const baseDelay = 1000; 
    const maxDelay = 10000; 
    const resetThreshold = 5; 

    while (true) {
      
      try {
        if (!this.channel) {
          throw new Error('RabbitMQ каналът не е наличен!');
        }

        await this.channel.sendToQueue(queue, Buffer.from(JSON.stringify(message)), { persistent: true, priority });

        this.logger.log(`✅ Съобщението до ${queue} е изпратено успешно!`);

        
        if (attempts >= resetThreshold) {
          attempts = 0;
        }

        return; 
      } catch (error) {
        attempts++;
        const adaptiveDelay = Math.min(baseDelay * attempts, maxDelay);

        this.logger.warn(
          `🔄 RabbitMQ недостъпен. Опит #${attempts}. 
          📌 Причина: ${error.message} 
          ⏳ Изчакване ${adaptiveDelay} ms и нов опит...`,
        );

        await new Promise((resolve) => setTimeout(resolve, adaptiveDelay));
      }
    }
  }

  async consumeDLQ(queue: string) {
    this.channel.consume(
      queue,
      async (msg) => {
        if (msg) {
          try {
            const messageData = JSON.parse(msg.content.toString());
            this.logger.warn(`📌 DLQ (${queue}) съобщение: ${JSON.stringify(messageData)}`);

            this.sendSlackAlert(`[${queue}] DLQ Message: ${JSON.stringify(messageData)}`);

            
            messageData.retryCount = (messageData.retryCount || 0) + 1;

            
            if (messageData.retryCount > 5) {
              this.logger.warn(`🚨 Достигнат максимален брой retry за ${queue}. Преместване в failed_queue.`);
              await this.sendMessage('failed_queue', messageData);
              this.channel.ack(msg); 
              return;
            }

            
            const delay = this.calculateBackoffDelay(messageData.retryCount);

            this.logger.log(`🔄 Повторно изпращане на съобщение от ${queue} към retry_queue след ${delay / 1000} секунди (Опит #${messageData.retryCount})`);

            
            setTimeout(async () => {
              await this.sendMessage('retry_queue', messageData);
            }, delay);

            
            this.loggingService.error('DLQ Message:', JSON.stringify(messageData), queue);
            this.dlqMessageCount.inc();

            this.channel.ack(msg); 
          } catch (error) {
            this.logger.error(`❌ Грешка при обработка на DLQ (${queue}): ${error.message}`);
            this.channel.nack(msg, false, true); 
          }
        }
      },
      { noAck: false },
    );
  }

  async sendSlackAlert(message: string) {
    await fetch('https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text: `⚠️ RabbitMQ DLQ Alert: ${message}` }),
    });
  }

  
  calculateRetryDelay(queue: string, messageAge: number): number {
    const baseDelays = {
      user_dlq: 5000, 
      payment_dlq: 10000, 
      order_dlq: 20000, 
    };
    const maxDelays = {
      user_dlq: 60000,
      payment_dlq: 120000,
      order_dlq: 180000,
    };

    const baseDelay = baseDelays[queue] || 5000;
    const maxDelay = maxDelays[queue] || 60000;

    return Math.min(2 ** Math.floor(messageAge / 10) * baseDelay, maxDelay);
  }

  async retryMessage(queue: string, msg: amqp.ConsumeMessage) {
    try {
      const messageData = JSON.parse(msg.content.toString());

      
      messageData.retryCount = (messageData.retryCount || 0) + 1;

      
      if (messageData.retryCount > 5) {
        this.logger.warn(`🚨 Max retry count reached for message in ${queue}. Moving to failed queue.`);
        await this.sendMessage('failed_queue', messageData);
        this.channel.ack(msg);
        return;
      }

      
      const delay = this.calculateBackoffDelay(messageData.retryCount);

      this.logger.log(`🔄 Retrying message from ${queue} in ${delay / 1000}s (Attempt #${messageData.retryCount})`);

      
      setTimeout(async () => {
        await this.sendMessage('retry_queue', messageData);
      }, delay);

      this.channel.ack(msg); 
    } catch (error) {
      this.logger.error(`❌ Error retrying message: ${error.message}`);
      this.channel.nack(msg, false, false);
    }
  }

  async onModuleDestroy() {
    this.logger.warn('⚠️ Application is being destroyed. Closing RabbitMQ connection...');
    try {
      if (this.channel) {
        await this.channel.close();
        this.logger.log('🔌 RabbitMQ Channel closed.');
      }
      if (this.connection) {
        await this.connection.close();
        this.logger.log('🔌 RabbitMQ Connection closed.');
      }
    } catch (error) {
      this.logger.error(`❌ Error closing RabbitMQ connection: ${error.message}`);
    }
  }

  private calculateBackoffDelay(retryCount: number): number {
    const baseDelay = 5000; 
    const maxDelay = 120000; 
    const jitter = Math.floor(Math.random() * 1000); 
    return Math.min(baseDelay * Math.pow(2, retryCount) + jitter, maxDelay);
  }

  
  async listDLQMessages(queue: string, limit: number = 20, filter?: string): Promise<any[]> {
    try {
      if (!this.channel || !this.isRabbitAvailable) {
        throw new Error('RabbitMQ channel is not available');
      }

      const { messageCount } = await this.channel.checkQueue(queue);
      if (messageCount === 0) {
        return [];
      }

      
      
      const messages = [];
      for (let i = 0; i < Math.min(limit, messageCount); i++) {
        const msg = await this.channel.get(queue, { noAck: false });
        if (!msg) break;

        try {
          const content = JSON.parse(msg.content.toString());

          
          if (filter && !JSON.stringify(content).includes(filter)) {
            this.channel.nack(msg, false, true); 
            continue;
          }

          messages.push({
            messageId: msg.properties.messageId || 'unknown',
            content,
            timestamp: msg.properties.timestamp || new Date().toISOString(),
            retryCount: content.retryCount || 0,
          });

          
          this.channel.nack(msg, false, true);
        } catch (error) {
          this.logger.error(`Error parsing message: ${error.message}`);
          this.channel.nack(msg, false, true);
        }
      }

      return messages;
    } catch (error) {
      this.logger.error(`Error listing DLQ messages: ${error.message}`);
      throw error;
    }
  }

  
  async getDLQStats(): Promise<any> {
    try {
      if (!this.channel || !this.isRabbitAvailable) {
        throw new Error('RabbitMQ channel is not available');
      }

      const dlqQueues = ['user_dlq', 'payment_dlq', 'order_dlq'];
      const stats = {};

      for (const queue of dlqQueues) {
        try {
          const queueInfo = await this.channel.checkQueue(queue);
          stats[queue] = {
            messageCount: queueInfo.messageCount,
            consumerCount: queueInfo.consumerCount,
          };
        } catch (error) {
          this.logger.error(`Error checking queue ${queue}: ${error.message}`);
          stats[queue] = { error: error.message };
        }
      }

      return stats;
    } catch (error) {
      this.logger.error(`Error getting DLQ stats: ${error.message}`);
      throw error;
    }
  }

  
  async retryAllMessages(queue: string, batchSize: number = 10): Promise<number> {
    try {
      if (!this.channel || !this.isRabbitAvailable) {
        throw new Error('RabbitMQ channel is not available');
      }

      const { messageCount } = await this.channel.checkQueue(queue);
      if (messageCount === 0) {
        return 0;
      }

      let processedCount = 0;

      
      for (let i = 0; i < Math.min(messageCount, batchSize); i++) {
        const msg = await this.channel.get(queue, { noAck: false });
        if (!msg) break;

        try {
          await this.retryMessage(queue, msg);
          processedCount++;
        } catch (error) {
          this.logger.error(`Error retrying message: ${error.message}`);
          this.channel.nack(msg, false, true); 
        }
      }

      return processedCount;
    } catch (error) {
      this.logger.error(`Error retrying all messages: ${error.message}`);
      throw error;
    }
  }

  
  async purgeQueue(queue: string): Promise<number> {
    try {
      if (!this.channel || !this.isRabbitAvailable) {
        throw new Error('RabbitMQ channel is not available');
      }

      const { messageCount } = await this.channel.checkQueue(queue);
      await this.channel.purgeQueue(queue);

      this.logger.log(`Purged ${messageCount} messages from ${queue}`);
      return messageCount;
    } catch (error) {
      this.logger.error(`Error purging queue ${queue}: ${error.message}`);
      throw error;
    }
  }
}



src\common\services\cache.service.ts:
import { Injectable } from '@nestjs/common';
import { RedisService } from './redis.service';

@Injectable()
export class CacheService {
  private readonly redisClient;

  constructor(private readonly redisService: RedisService) {
    this.redisClient = this.redisService.getClient();
  }

  async get(key: string): Promise<any> {
    try {
      const data = await this.redisClient.get(key);
      return data ? JSON.parse(data) : null;
    } catch (error) {
      console.error('Error fetching from cache:', error.message);
      return null;
    }
  }

  async set(key: string, value: any, ttl: number): Promise<void> {
    try {
      await this.redisClient.set(key, JSON.stringify(value), 'EX', ttl);
    } catch (error) {
      console.error('Error setting cache:', error.message);
    }
  }
}



src\common\services\cleanup.service.ts:
import { Injectable, OnModuleDestroy, OnApplicationShutdown, Logger } from '@nestjs/common';
import { RabbitMQProvider } from '../providers/rabbitmq.provider';
import { RedisService } from './redis.service';
import { DataSource } from 'typeorm';

@Injectable()
export class CleanupService implements OnModuleDestroy, OnApplicationShutdown {
  private readonly logger = new Logger(CleanupService.name);

  constructor(
    private readonly rabbitMQProvider: RabbitMQProvider,
    private readonly redisService: RedisService,
    private readonly dataSource: DataSource,
  ) {}

  async onModuleDestroy() {
    this.logger.warn('🛑 Cleanup before module destroy...');
    await this.cleanupResources();
  }

  async onApplicationShutdown(signal?: string) {
    this.logger.warn(`🚦 Application shutting down due to: ${signal}`);
    await this.cleanupResources();
  }

  private async cleanupResources() {
    this.logger.log('🔌 Closing connections to RabbitMQ, Redis, and Database...');

    try {
      await this.rabbitMQProvider.onModuleDestroy();
      this.logger.log('✅ RabbitMQ connection closed.');
    } catch (error) {
      this.logger.error(`❌ Error closing RabbitMQ: ${error.message}`);
    }

    try {
      const redisClient = this.redisService.getClient();
      if (redisClient) {
        await redisClient.quit();
        this.logger.log('✅ Redis connection closed.');
      }
    } catch (error) {
      this.logger.error(`❌ Error closing Redis: ${error.message}`);
    }

    try {
      if (this.dataSource.isInitialized) {
        await this.dataSource.destroy();
        this.logger.log('✅ Database connection closed.');
      }
    } catch (error) {
      this.logger.error(`❌ Error closing Database: ${error.message}`);
    }
  }
}



src\common\services\event.service.ts:
import { Injectable, Inject } from '@nestjs/common';
import { ClientProxy } from '@nestjs/microservices';
import { LoggingService } from './logging.service';

@Injectable()
export class EventService {
  constructor(
    @Inject('RABBITMQ_SERVICE') private readonly rabbitMQClient: ClientProxy,
    private readonly loggingService: LoggingService,
  ) {}

  async emitEvent(eventName: string, payload: unknown) {
    try {
      await this.rabbitMQClient.emit(eventName, payload);
      this.loggingService.log(`Event '${eventName}' emitted successfully with payload: ${JSON.stringify(payload)}`);
    } catch (error) {
      this.loggingService.error(`Error emitting event '${eventName}': ${error.message}`, error.stack);
      throw error;
    }
  }

  async testDlx() {
    console.log('📤 Изпращане на тестово съобщение...');
    await this.rabbitMQClient.emit('user_registered', {
      username: 'error_user',
    });
  }
}



src\common\services\logging.service.ts:
import { Injectable, Inject } from '@nestjs/common';
import { Logger } from '@nestjs/common';
import { Client } from '@elastic/elasticsearch';

@Injectable()
export class LoggingService {
  private readonly logger = new Logger('GlobalLogger');

  constructor(
    @Inject('ELASTICSEARCH_CLIENT')
    private readonly elasticsearchClient: Client,
  ) {}

  async log(message: string, context?: string) {
    try {
      const logContext = context || 'GlobalLogger';
      this.logger.log(`[${new Date().toISOString()}] ${message}`, logContext);

      
      await this.elasticsearchClient.index({
        index: 'nestjs-logs', 
        body: {
          timestamp: new Date().toISOString(),
          level: 'info',
          message,
          context: logContext,
        },
      });
    } catch (error) {
      this.logger.error('Failed to send log to Elasticsearch:', error);
    }
  }

  async error(message: string, trace?: string, context?: string) {
    const logContext = context || 'GlobalLogger';
    this.logger.error(`[${new Date().toISOString()}] ${message}`, trace, logContext);

    
    await this.elasticsearchClient.index({
      index: 'nestjs-logs',
      body: {
        timestamp: new Date().toISOString(),
        level: 'error',
        message,
        context: logContext,
        trace,
      },
    });
    
    if (context === 'DeadLetterQueue') {
      await this.elasticsearchClient.index({
        index: 'dlq-logs',
        body: {
          timestamp: new Date().toISOString(),
          message,
          trace,
        },
      });
    }
  }

  async warn(message: string, context?: string) {
    const logContext = context || 'GlobalLogger';
    this.logger.warn(`[${new Date().toISOString()}] ${message}`, logContext);

    await this.elasticsearchClient.index({
      index: 'nestjs-logs',
      body: {
        timestamp: new Date().toISOString(),
        level: 'warn',
        message,
        context: logContext,
      },
    });
  }
}



src\common\services\metrics.service.ts:
import { Injectable } from '@nestjs/common';
import { Counter, Histogram, Gauge } from 'prom-client';
import { InjectMetric } from '@willsoto/nestjs-prometheus';

@Injectable()
export class MetricsService {
  constructor(
    @InjectMetric('PROM_METRIC_USER_REGISTERED_TOTAL') 
    private readonly registeredUsersCounter: Counter<string>,

    @InjectMetric('PROM_METRIC_USER_REQUEST_DURATION_SECONDS') 
    private readonly requestDurationHistogram: Histogram<string>,
  ) {}


  incrementCounter(labels?: Record<string, string | number>) {
    if (labels) {
      this.registeredUsersCounter.inc(labels);
    } else {
      this.registeredUsersCounter.inc();
    }
  }


  startTimer(labels?: Record<string, string | number>): () => void {
    return this.requestDurationHistogram.startTimer(labels);
  }

  setGauge(gauge: Gauge<string>, value: number, labels?: Record<string, string | number>) {
    if (labels) {
      gauge.set(labels, value);
    } else {
      gauge.set(value);
    }
  }
}



src\common\services\redis.service.ts:
import { Injectable } from '@nestjs/common';
import Redis from 'ioredis';
import { ConfigService } from '@nestjs/config';
import { getRedisConfig } from '../config/redis.config';

@Injectable()
export class RedisService {
  private readonly redisClient: Redis;

  constructor(private readonly configService: ConfigService) {
    this.redisClient = new Redis({
      ...getRedisConfig(this.configService),
      connectTimeout: 10, 
      maxRetriesPerRequest: 0, 
      retryStrategy: (times: number) => {
        const delay = Math.min(times * 100, 2000); 
        console.error(`Redis connection failed. Retry in ${delay} ms.`);
        return delay;
      },
      reconnectOnError: (err: Error) => {
        console.error('Redis reconnectOnError triggered:', err.message);
        return true;
      },
    });
    this.attachEventListeners();
  }

  private attachEventListeners() {
    this.redisClient.on('connect', () => {
      console.log('Redis connected.');
    });

    this.redisClient.on('ready', () => {
      console.log('Redis is ready to use.');
    });

    this.redisClient.on('error', (error) => {
      console.error('Redis error:', error.message);
    });

    this.redisClient.on('close', () => {
      console.warn('Redis connection closed.');
    });

    this.redisClient.on('reconnecting', (delay) => {
      console.log(`Redis is trying to reconnect. Next attempt in ${delay} ms.`);
    });
  }

  getClient(): Redis {
    return this.redisClient;
  }
}



src\common\common.module.ts:
import { Module, Global, forwardRef } from '@nestjs/common';
import { LoggingService } from './services/logging.service';
import { RpcExceptionFilter } from './filters/rpc-exception.filter';
import { GlobalExceptionFilter } from './filters/global-exception.filter';
import { RedisService } from './services/redis.service';
import { LoggingInterceptor } from './interceptors/logging.interceptor';
import { CacheService } from './services/cache.service';
import { EventService } from './services/event.service';
import { ClientsModule, Transport } from '@nestjs/microservices';
import { MetricsModule } from './metrics/metrics.module';
import { MetricsService } from './services/metrics.service';
import { createElasticsearchClient } from './config/elasticsearch.config';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { ElasticsearchTestController } from './controllers/elasticsearch-test.controller';
import { InterceptorTestController } from './controllers/interceptorTest.controller';
import { PrometheusModule, makeCounterProvider, makeGaugeProvider, makeHistogramProvider } from '@willsoto/nestjs-prometheus';
import { RabbitMQProvider } from './providers/rabbitmq.provider';
import { DLQController } from './controllers/dlq.controller';
import { CleanupService } from './services/cleanup.service';
import { AuthModule } from '../auth/auth.module';

@Global() 
@Module({
  imports: [
    PrometheusModule,
    ConfigModule,
    MetricsModule,
    
    ClientsModule.registerAsync([
      {
        name: 'RABBITMQ_SERVICE',
        imports: [ConfigModule],
        inject: [ConfigService],
        useFactory: (configService: ConfigService) => ({
          transport: Transport.RMQ,
          options: {
            urls: [`amqp://${configService.get('RABBITMQ_DEFAULT_USER')}:${configService.get('RABBITMQ_DEFAULT_PASS')}@localhost:5672`],
            queue: 'user_queue',
            queueOptions: {
              durable: true,
              arguments: {
                'x-dead-letter-exchange': 'dlx_exchange', 
                'x-dead-letter-routing-key': 'dlx_routing_key', 
              },
            },
          },
        }),
      },
    ]),
    forwardRef(() => AuthModule), 
  ],
  controllers: [DLQController, ElasticsearchTestController, InterceptorTestController],
  providers: [
    {
      provide: 'ELASTICSEARCH_CLIENT',
      useFactory: (configService: ConfigService) => createElasticsearchClient(configService),
      inject: [ConfigService],
    },
    CleanupService,
    LoggingService,
    RpcExceptionFilter,
    GlobalExceptionFilter,
    RedisService,
    CacheService,
    LoggingInterceptor,
    EventService,
    MetricsService,
    RabbitMQProvider,
    
    makeCounterProvider({
      name: 'dlq_message_count', 
      help: 'Count of messages in Dead Letter Queue',
      labelNames: ['queue'],
    }),
    makeGaugeProvider({
      name: 'dlq_message_age_seconds', 
      help: 'Age of messages in Dead Letter Queue in seconds',
      labelNames: ['queue'],
    }),
    
    makeCounterProvider({
      name: 'dlq_retry_attempts_total',
      help: 'Total number of DLQ retry attempts',
      labelNames: ['queue'],
    }),
    makeCounterProvider({
      name: 'dlq_retry_success_total',
      help: 'Total number of successful DLQ retries',
      labelNames: ['queue'],
    }),
    makeGaugeProvider({
      name: 'dlq_message_count_gauge',
      help: 'Current number of messages in DLQ',
      labelNames: ['queue'],
    }),
    makeHistogramProvider({
      name: 'PROM_METRIC_USER_REQUEST_DURATION_SECONDS',
      help: 'Duration of user requests in seconds',
      buckets: [0.1, 0.5, 1, 2, 5],
    }),
  ], 
  exports: [
    CleanupService,
    LoggingService,
    RpcExceptionFilter,
    GlobalExceptionFilter,
    RedisService,
    CacheService,
    LoggingInterceptor,
    EventService,
    ClientsModule,
    MetricsService,
    RabbitMQProvider,
    PrometheusModule,
    MetricsModule,
  ], 
})
export class CommonModule {}



src\user\dto\register-user.dto.ts:
import { IsString, MinLength, MaxLength } from 'class-validator';

export class RegisterUserDto {
  @IsString()
  @MinLength(3, { message: 'Username must be at least 3 characters long' })
  @MaxLength(20, { message: 'Username must not exceed 20 characters' })
  username: string;

  @IsString()
  @MinLength(8, { message: 'Password must be at least 8 characters long' })
  @MaxLength(30, { message: 'Password must not exceed 30 characters' })
  password: string;
}



src\user\main.ts:


import { NestFactory } from '@nestjs/core';
import { UserModule } from './user.module';
import { MicroserviceOptions, Transport } from '@nestjs/microservices';
import { Logger, ValidationPipe } from '@nestjs/common';
import { RpcExceptionFilter } from '../common/filters/rpc-exception.filter';
import { ConfigService } from '@nestjs/config';
import { GlobalExceptionFilter } from '../common/filters/global-exception.filter';
import { CleanupService } from '../common/services/cleanup.service';

const logger = new Logger('Bootstrap');


function getTransportOptions(configService: ConfigService): MicroserviceOptions {
  return {
    transport: Transport.TCP,
    options: {
      host: 'localhost',
      port: configService.get<number>('USER_SERVICE_PORT'),
    },
  };
}


async function bootstrap() {
  try {
    const appContext = await NestFactory.createApplicationContext(UserModule);
    const configService = appContext.get(ConfigService);

    
    const app = await NestFactory.createMicroservice<MicroserviceOptions>(UserModule, getTransportOptions(configService));

    
    const httpServer = await NestFactory.create(UserModule);

    
    
    
    
    
    
    
    
    
    app.useGlobalPipes(
      new ValidationPipe({
        whitelist: true, 
        forbidNonWhitelisted: true, 
        transform: true, 
      }),
    );

    
    
    
    const globalExceptionFilter = app.get(GlobalExceptionFilter);
    app.useGlobalFilters(globalExceptionFilter);

    const rpcExceptionFilter = app.get(RpcExceptionFilter);
    app.useGlobalFilters(rpcExceptionFilter);

    const cleanupService = app.get(CleanupService);
    process.on('SIGINT', async () => {
      console.log('🛑 SIGINT received. Gracefully shutting down...');
      await cleanupService.onApplicationShutdown('SIGINT');
      process.exit(0);
    });
    process.on('SIGTERM', async () => {
      console.log('🛑 SIGTERM received. Gracefully shutting down...');
      await cleanupService.onApplicationShutdown('SIGTERM');
      process.exit(0);
    });

    
    await app.listen();
    logger.log('✅ [UserService] Microservice is running on localhost:3001');

    
    await httpServer.listen(3002); 
    logger.log('✅ [UserService] Prometheus metrics are available on http://localhost:3002/metrics');
  } catch (error) {
    logger.error('❌ Failed to start UserService:', error.message, error.stack);
    process.exit(1);
  }
}

bootstrap();



src\user\user.consumer.ts:
import { Injectable } from '@nestjs/common';
import { MessagePattern, Payload } from '@nestjs/microservices';

@Injectable()
export class UserConsumer {
  @MessagePattern('user_registered')
  async handleUserRegistered(@Payload() data: { username: string; id: number }) {
    try {
      console.log(`Received user_registered event:`, data);
      
    } catch (error) {
      console.error(`Error processing user_registered event: ${error.message}`);
      throw error; 
    }
  }

  @MessagePattern('retry_user_registered')
  async handleRetryUserRegistered(@Payload() data: { username: string; id: number }) {
    try {
      console.log(`Retrying user_registered event:`, data);
      
    } catch (error) {
      console.error(`Retry failed for user_registered event: ${error.message}`);
      throw error; 
    }
  }
}



src\user\user.controller.ts:


import { Controller, Body, UseInterceptors } from '@nestjs/common';
import { AuthService } from '../auth/auth.service';
import { MessagePattern } from '@nestjs/microservices';
import { UserService } from './user.service';

import { RegisterUserDto } from './dto/register-user.dto';
import { LoggingInterceptor } from '../common/interceptors/logging.interceptor';


@Controller()

@UseInterceptors(LoggingInterceptor)
export class UserController {
  constructor(
    private readonly userService: UserService,
    private readonly authService: AuthService,
  ) {}

  @MessagePattern('login') 
  async handleLogin(@Body() loginDto: { username: string; password: string }) {
    console.log(`Handling login request for user: ${loginDto.username}`);
    const user = await this.authService.validateUser(loginDto.username, loginDto.password);
    if (!user) {
      console.log(`Invalid credentials for user: ${loginDto.username}`);
      throw new Error('Invalid credentials');
    }
    console.log(`Login successful for user: ${loginDto.username}`);
    return this.authService.login(user);
  }

  
  
  @MessagePattern('register_user')

  async handleRegisterUser(data: RegisterUserDto) {
    
    return this.userService.register(data.username, data.password);
  }

  @MessagePattern('get_user_by_username')
  async handleGetUserByUsername(data: { username: string }) {
    console.log('Received get_user_by_username request for username:', data.username);
    return this.userService.getUserByUsername(data.username);
  }
}



src\user\user.entity.ts:

import { Entity, PrimaryGeneratedColumn, Column } from 'typeorm';

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  username: string;

  @Column()
  password: string;

  
}



src\user\user.module.ts:


import { Module, forwardRef } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { UserController } from './user.controller';
import { UserService } from './user.service';
import { User } from './user.entity';
import { CommonModule } from '../common/common.module';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { MetricsModule } from '../common/metrics/metrics.module';
import { UserConsumer } from './user.consumer'; 
import { CacheModule } from '@nestjs/cache-manager';
import { getRedisConfig } from '../common/config/redis.config';
import { AuthModule } from '../auth/auth.module'; 
import { configValidationSchema } from '../common/config/validation.schema';
import { EventService } from '../common/services/event.service'; 
import { MetricsService } from '../common/services/metrics.service'; 

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true, 
      envFilePath: `.env.${process.env.NODE_ENV || 'development'}`, 
      validationSchema: configValidationSchema,
    }),
    
    TypeOrmModule.forRootAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: (configService: ConfigService) => ({
        type: 'postgres',
        host: configService.get<string>('DATABASE_HOST'),
        port: +configService.get<number>('DATABASE_PORT'),
        username: configService.get<string>('DATABASE_USER'),
        password: configService.get<string>('DATABASE_PASSWORD'),
        database: configService.get<string>('DATABASE_NAME'),
        entities: [User], 
        synchronize: true, 
        logging: true,
      }),
    }),
    TypeOrmModule.forFeature([User]), 
    CommonModule, 
    MetricsModule, 
    CacheModule.registerAsync({
      inject: [ConfigService],
      useFactory: (configService: ConfigService) => ({
        store: 'ioredis',
        ...getRedisConfig(configService), 
      }),
    }),
    forwardRef(() => AuthModule), 
  ],
  providers: [
    UserService,
    UserConsumer, 

    EventService, 
    MetricsService, 
  ],
  controllers: [UserController],
  exports: [UserService], 
})
export class UserModule {}



src\user\user.repository.ts:
import { Injectable } from '@nestjs/common';
import { DataSource, Repository } from 'typeorm';
import { User } from './user.entity';

@Injectable()
export class UserRepository extends Repository<User> {
  constructor(private readonly dataSource: DataSource) {
    super(User, dataSource.createEntityManager());
  }

  async findByUsername(username: string): Promise<User | null> {
    return this.findOne({ where: { username } });
  }

  async createUser(username: string, password: string): Promise<User> {
    const user = this.create({ username, password });
    return this.save(user);
  }
}



src\user\user.service.ts:
import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from './user.entity';
import { LoggingService } from '../common/services/logging.service';
import { CacheService } from '../common/services/cache.service';
import { EventService } from '../common/services/event.service';
import { MetricsService } from '../common/services/metrics.service';
import { RabbitMQProvider } from '../common/providers/rabbitmq.provider';

@Injectable()
export class UserService {
  constructor(
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
    private readonly rabbitMQProvider: RabbitMQProvider,
    private readonly loggingService: LoggingService,
    private readonly cacheService: CacheService,
    private readonly eventService: EventService,
    private readonly metricsService: MetricsService,
  ) {}

  async register(username: string, password: string) {
    const endTimer = this.metricsService.startTimer(); 
    this.loggingService.log(`Регистрираме потребител: ${username}`);

    const existingUser = await this.userRepository.findOne({
      where: { username },
    });
    if (existingUser) {
      this.loggingService.warn(`Потребителското име "${username}" вече съществува.`);
      throw new BadRequestException('Потребителското име вече съществува');
    }

    const newUser = this.userRepository.create({ username, password });
    const savedUser = await this.userRepository.save(newUser);

    this.loggingService.log(`Потребител "${username}" регистриран успешно.`);
    this.metricsService.incrementCounter(); 
    endTimer(); 

    
    this.rabbitMQProvider
      .sendMessage('user_registered', {
        id: savedUser.id,
        username: savedUser.username,
      })
      .catch((error) => {
        this.loggingService.warn(`⚠️ Не можахме да изпратим user_registered event към RabbitMQ: ${error.message}`);
      });

    
    await this.eventService.emitEvent('user_registered', {
      username: savedUser.username,
      id: savedUser.id,
    });

    return savedUser;
  }

  async getUserByUsername(username: string) {
    const cachedUser = await this.cacheService.get(`user:${username}`);
    if (cachedUser) {
      console.log('Cache hit for user:', username);
      return cachedUser;
    }

    const user = await this.userRepository.findOne({ where: { username } });
    if (!user) {
      throw new NotFoundException('User not found');
    }

    await this.cacheService.set(`user:${username}`, user, 3600);
    return user;
  }
}



.env.development:
USER_SERVICE_PORT=3001
DATABASE_HOST=localhost
DATABASE_PORT=5432
DATABASE_USER=postgres
DATABASE_PASSWORD=456321
DATABASE_NAME=users
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=456321
JWT_SECRET=7aa50db0d30c858bc18b5228aa0975ca67cc9653b8eb31e9f046ab1752557f078ace6fcf1f5df813346fb98ec1de806cdb918098b2389e660927291423f60f74
RABBITMQ_DEFAULT_USER=rabbitMQAdmin
RABBITMQ_DEFAULT_PASS=rabbitMQAdminPassword
ELASTIC_PASSWORD=456321
KIBANA_PASSWORD=456321
STACK_VERSION=8.17.1
CLUSTER_NAME=docker-cluster
LICENSE=basic
#LICENSE=trial
ES_PORT=9200
#ES_PORT=127.0.0.1:9200
KIBANA_PORT=5601
#KIBANA_PORT=80
MEM_LIMIT=1073741824
#COMPOSE_PROJECT_NAME=myproject
ELASTICSEARCH_NODE=https://localhost:9200
ELASTICSEARCH_USERNAME=elastic
ELASTICSEARCH_PASSWORD=456321
ELASTICSEARCH_CA_CERT=./elasticsearch-certs/ca/ca.crt


.env.test:



docker-compose-async-operations.yml:
version: '3.8'

services:
  rabbitmq:
    image: rabbitmq:4-management
    container_name: rabbitmq
    ports:
      - "5672:5672"
      - "15672:15672"
    environment:
      RABBITMQ_DEFAULT_USER: ${RABBITMQ_DEFAULT_USER:-admin}
      RABBITMQ_DEFAULT_PASS: ${RABBITMQ_DEFAULT_PASS:-admin}
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq
    networks:
      - rabbitmq-network
    healthcheck:
      test: ["CMD", "rabbitmqctl", "status"]
      interval: 30s
      timeout: 10s
      retries: 3
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
    restart: unless-stopped
    labels:
      - "com.example.description=RabbitMQ message broker for QA-4-Free project"
      - "com.example.version=4"
      - "com.example.maintainer=Your Name <your.email@example.com>"

  rabbitmq-exporter:
    image: kbudde/rabbitmq-exporter
    container_name: rabbitmq-exporter
    ports:
      - "9419:9419"
    environment:
      RABBIT_URL: "http://rabbitMQAdmin:rabbitMQAdminPassword@rabbitmq:15672"
      PUBLISH_PORT: "9419"
    networks:
      - rabbitmq-network
    depends_on:
      - rabbitmq
    restart: unless-stopped
    labels:
      - "com.example.description=RabbitMQ Prometheus Exporter"
      - "com.example.version=latest"
      - "com.example.maintainer=Your Name <your.email@example.com>"

volumes:
  rabbitmq_data:

networks:
  rabbitmq-network:
    name: rabbitmq-network
    driver: bridge



docker-compose-cache.yml:
version: '3.8'

services:
  redis:
    image: redis:6.2-alpine
    container_name: redis
    ports:
      - "6379:6379"
    environment:
      REDIS_PASSWORD: ${REDIS_PASSWORD:-your_secure_password}
    command: redis-server --requirepass ${REDIS_PASSWORD:-your_secure_password}
    volumes:
      - redis_data:/data
    networks:
      - cache-network
    healthcheck:
      test: ["CMD", "redis-cli", "-a", "${REDIS_PASSWORD:-your_secure_password}", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 256M
    restart: unless-stopped
    labels:
      - "com.example.description=Redis cache for QA-4-Free project"
      - "com.example.version=6.2"
      - "com.example.maintainer=Your Name <your.email@example.com>"

  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
    networks:
      - cache-network
    depends_on:
      - redis

  grafana:
    image: grafana/grafana:latest
    container_name: grafana
    ports:
      - "3003:3000"
    volumes:
      - grafana_data:/var/lib/grafana
    networks:
      - cache-network
    depends_on:
      - prometheus
    environment:
      - GF_SECURITY_ADMIN_USER=admin
      - GF_SECURITY_ADMIN_PASSWORD=admin

  redis-commander:
    image: rediscommander/redis-commander:latest
    container_name: redis-commander
    ports:
      - "8081:8081"
    environment:
      - REDIS_HOSTS=local:redis:6379:0:${REDIS_PASSWORD}
      - HTTP_USER=admin
      - HTTP_PASSWORD=admin
    networks:
      - cache-network
    depends_on:
      - redis

  redisinsight:
    image: redislabs/redisinsight:latest
    container_name: redisinsight
    ports:
      - "8001:8001"
    volumes:
      - redisinsight_data:/db
    networks:
      - cache-network
    depends_on:
      - redis

volumes:
  redis_data:
  grafana_data:
  redisinsight_data:

networks:
  cache-network:
    name: cache-network
    driver: bridge


docker-compose-log.yml:
version: "2.2"

services:
  setup:
    image: docker.elastic.co/elasticsearch/elasticsearch:${STACK_VERSION}
    volumes:
      - ./elasticsearch-certs:/usr/share/elasticsearch/config/certs
    user: "0"
    command: >
      bash -c '
        if [ x${ELASTIC_PASSWORD} == x ]; then
          echo "Set the ELASTIC_PASSWORD environment variable in the .env file";
          exit 1;
        elif [ x${KIBANA_PASSWORD} == x ]; then
          echo "Set the KIBANA_PASSWORD environment variable in the .env file";
          exit 1;
        fi;
        if [ ! -f config/certs/ca.zip ]; then
          echo "Creating CA";
          bin/elasticsearch-certutil ca --silent --pem -out config/certs/ca.zip;
          unzip config/certs/ca.zip -d config/certs;
        fi;
        if [ ! -f config/certs/certs.zip ]; then
          echo "Creating certs";
          echo -ne \
          "instances:\n"\
          "  - name: es01\n"\
          "    dns:\n"\
          "      - es01\n"\
          "      - localhost\n"\
          "    ip:\n"\
          "      - 127.0.0.1\n"\
          "  - name: es02\n"\
          "    dns:\n"\
          "      - es02\n"\
          "      - localhost\n"\
          "    ip:\n"\
          "      - 127.0.0.1\n"\
          "  - name: es03\n"\
          "    dns:\n"\
          "      - es03\n"\
          "      - localhost\n"\
          "    ip:\n"\
          "      - 127.0.0.1\n"\
          > config/certs/instances.yml;
          bin/elasticsearch-certutil cert --silent --pem -out config/certs/certs.zip --in config/certs/instances.yml --ca-cert config/certs/ca/ca.crt --ca-key config/certs/ca/ca.key;
          unzip config/certs/certs.zip -d config/certs;
        fi;
        echo "Setting file permissions"
        chown -R root:root config/certs;
        find . -type d -exec chmod 750 \{\} \;;
        find . -type f -exec chmod 640 \{\} \;;
        echo "Waiting for Elasticsearch availability";
        until curl -s --cacert config/certs/ca/ca.crt https://es01:9200 | grep -q "missing authentication credentials"; do sleep 30; done;
        echo "Setting kibana_system password";
        until curl -s -X POST --cacert config/certs/ca/ca.crt -u "elastic:${ELASTIC_PASSWORD}" -H "Content-Type: application/json" https://es01:9200/_security/user/kibana_system/_password -d "{\"password\":\"${KIBANA_PASSWORD}\"}" | grep -q "^{}"; do sleep 10; done;
        echo "All done!";
        chmod 644 config/certs/ca/ca.crt;
      '
    healthcheck:
      test: ["CMD-SHELL", "[ -f config/certs/es01/es01.crt ]"]
      interval: 5s
      timeout: 10s
      retries: 30
    networks:
      - log-network

  es01:
    depends_on:
      setup:
        condition: service_healthy
    image: docker.elastic.co/elasticsearch/elasticsearch:${STACK_VERSION}
    volumes:
      - ./elasticsearch-certs:/usr/share/elasticsearch/config/certs
      - esdata01:/usr/share/elasticsearch/data
    ports:
      - ${ES_PORT}:9200
    environment:
      - node.name=es01
      - cluster.name=${CLUSTER_NAME}
      - cluster.initial_master_nodes=es01,es02,es03
      - discovery.seed_hosts=es02,es03
      - ELASTIC_PASSWORD=${ELASTIC_PASSWORD}
      - bootstrap.memory_lock=true
      - xpack.security.enabled=true
      - xpack.security.http.ssl.enabled=true
      - xpack.security.http.ssl.key=certs/es01/es01.key
      - xpack.security.http.ssl.certificate=certs/es01/es01.crt
      - xpack.security.http.ssl.certificate_authorities=certs/ca/ca.crt
      - xpack.security.transport.ssl.enabled=true
      - xpack.security.transport.ssl.key=certs/es01/es01.key
      - xpack.security.transport.ssl.certificate=certs/es01/es01.crt
      - xpack.security.transport.ssl.certificate_authorities=certs/ca/ca.crt
      - xpack.security.transport.ssl.verification_mode=certificate
      - xpack.license.self_generated.type=${LICENSE}
      - xpack.ml.use_auto_machine_memory_percent=true
    mem_limit: ${MEM_LIMIT}
    ulimits:
      memlock:
        soft: -1
        hard: -1
    healthcheck:
      test:
        [
          "CMD-SHELL",
          "curl -s --cacert config/certs/ca/ca.crt https://localhost:9200 | grep -q 'missing authentication credentials'",
        ]
      interval: 10s
      timeout: 10s
      retries: 120
    networks:
      - log-network

  es02:
    depends_on:
      - es01
    image: docker.elastic.co/elasticsearch/elasticsearch:${STACK_VERSION}
    volumes:
      - ./elasticsearch-certs:/usr/share/elasticsearch/config/certs
      - esdata02:/usr/share/elasticsearch/data
    environment:
      - node.name=es02
      - cluster.name=${CLUSTER_NAME}
      - cluster.initial_master_nodes=es01,es02,es03
      - discovery.seed_hosts=es01,es03
      - ELASTIC_PASSWORD=${ELASTIC_PASSWORD}
      - bootstrap.memory_lock=true
      - xpack.security.enabled=true
      - xpack.security.http.ssl.enabled=true
      - xpack.security.http.ssl.key=certs/es02/es02.key
      - xpack.security.http.ssl.certificate=certs/es02/es02.crt
      - xpack.security.http.ssl.certificate_authorities=certs/ca/ca.crt
      - xpack.security.transport.ssl.enabled=true
      - xpack.security.transport.ssl.key=certs/es02/es02.key
      - xpack.security.transport.ssl.certificate=certs/es02/es02.crt
      - xpack.security.transport.ssl.certificate_authorities=certs/ca/ca.crt
      - xpack.security.transport.ssl.verification_mode=certificate
      - xpack.license.self_generated.type=${LICENSE}
      - xpack.ml.use_auto_machine_memory_percent=true
    mem_limit: ${MEM_LIMIT}
    ulimits:
      memlock:
        soft: -1
        hard: -1
    healthcheck:
      test:
        [
          "CMD-SHELL",
          "curl -s --cacert config/certs/ca/ca.crt https://localhost:9200 | grep -q 'missing authentication credentials'",
        ]
      interval: 10s
      timeout: 10s
      retries: 120
    networks:
      - log-network

  es03:
    depends_on:
      - es02
    image: docker.elastic.co/elasticsearch/elasticsearch:${STACK_VERSION}
    volumes:
      - ./elasticsearch-certs:/usr/share/elasticsearch/config/certs
      - esdata03:/usr/share/elasticsearch/data
    environment:
      - node.name=es03
      - cluster.name=${CLUSTER_NAME}
      - cluster.initial_master_nodes=es01,es02,es03
      - discovery.seed_hosts=es01,es02
      - ELASTIC_PASSWORD=${ELASTIC_PASSWORD}
      - bootstrap.memory_lock=true
      - xpack.security.enabled=true
      - xpack.security.http.ssl.enabled=true
      - xpack.security.http.ssl.key=certs/es03/es03.key
      - xpack.security.http.ssl.certificate=certs/es03/es03.crt
      - xpack.security.http.ssl.certificate_authorities=certs/ca/ca.crt
      - xpack.security.transport.ssl.enabled=true
      - xpack.security.transport.ssl.key=certs/es03/es03.key
      - xpack.security.transport.ssl.certificate=certs/es03/es03.crt
      - xpack.security.transport.ssl.certificate_authorities=certs/ca/ca.crt
      - xpack.security.transport.ssl.verification_mode=certificate
      - xpack.license.self_generated.type=${LICENSE}
      - xpack.ml.use_auto_machine_memory_percent=true
    mem_limit: ${MEM_LIMIT}
    ulimits:
      memlock:
        soft: -1
        hard: -1
    healthcheck:
      test:
        [
          "CMD-SHELL",
          "curl -s --cacert config/certs/ca/ca.crt https://localhost:9200 | grep -q 'missing authentication credentials'",
        ]
      interval: 10s
      timeout: 10s
      retries: 120
    networks:
      - log-network

  kibana:
    depends_on:
      es01:
        condition: service_healthy
      es02:
        condition: service_healthy
      es03:
        condition: service_healthy
    image: docker.elastic.co/kibana/kibana:${STACK_VERSION}
    volumes:
      - ./elasticsearch-certs:/usr/share/kibana/config/certs
      - kibanadata:/usr/share/kibana/data
    ports:
      - ${KIBANA_PORT}:5601
    environment:
      - SERVERNAME=kibana
      - ELASTICSEARCH_HOSTS=https://es01:9200
      - ELASTICSEARCH_USERNAME=kibana_system
      - ELASTICSEARCH_PASSWORD=${KIBANA_PASSWORD}
      - ELASTICSEARCH_SSL_CERTIFICATEAUTHORITIES=/usr/share/kibana/config/certs/ca/ca.crt
      - SERVER_SSL_ENABLED=true
      - SERVER_SSL_KEY=/usr/share/kibana/config/certs/es01/es01.key
      - SERVER_SSL_CERTIFICATE=/usr/share/kibana/config/certs/es01/es01.crt
      - SERVER_SSL_CERTIFICATEAUTHORITIES=/usr/share/kibana/config/certs/ca/ca.crt
    mem_limit: ${MEM_LIMIT}
    healthcheck:
      test:
        [
          "CMD-SHELL",
          "curl -s -I http://localhost:5601 | grep -q 'HTTP/1.1 302 Found'",
        ]
      interval: 10s
      timeout: 10s
      retries: 120
    networks:
      - log-network

volumes:
  certs:
    driver: local
  esdata01:
    driver: local
  esdata02:
    driver: local
  esdata03:
    driver: local
  kibanadata:
    driver: local

networks:
  log-network:
    name: log-network
    driver: bridge


nest-cli.json:
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}



package.json:
{
  "name": "project-name",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "user:dev": "cross-env NODE_ENV=development ts-node src/user/main.ts",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug:user": "node --inspect=9229 -r ts-node/register -r tsconfig-paths/register src/user/main.ts",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json",
    "prepare": "husky",
    "docker:dev": "docker-compose --env-file .env.development up -d"
  },
  "dependencies": {
    "@elastic/elasticsearch": "^8.17.0",
    "@nestjs/cache-manager": "^2.3.0",
    "@nestjs/common": "^10.4.15",
    "@nestjs/config": "^3.3.0",
    "@nestjs/core": "^10.0.0",
    "@nestjs/jwt": "^10.2.0",
    "@nestjs/microservices": "^10.4.15",
    "@nestjs/passport": "^10.0.3",
    "@nestjs/platform-express": "^10.0.0",
    "@nestjs/typeorm": "^10.0.2",
    "@willsoto/nestjs-prometheus": "^6.0.1",
    "amqp-connection-manager": "^4.1.14",
    "cache-manager-ioredis": "^2.1.0",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.1",
    "dotenv": "^16.4.7",
    "ioredis": "^5.4.2",
    "joi": "^17.13.3",
    "opossum": "^8.4.0",
    "passport-jwt": "^4.0.1",
    "pg": "^8.13.1",
    "prom-client": "^15.1.3",
    "reflect-metadata": "^0.2.0",
    "rxjs": "^7.8.1",
    "typeorm": "^0.3.20"
  },
  "devDependencies": {
    "@nestjs/cli": "^10.0.0",
    "@nestjs/schematics": "^10.0.0",
    "@nestjs/testing": "^10.4.15",
    "@types/express": "^5.0.0",
    "@types/jest": "^29.5.14",
    "@types/node": "^20.17.10",
    "@types/supertest": "^6.0.0",
    "@typescript-eslint/eslint-plugin": "^8.0.0",
    "@typescript-eslint/parser": "^8.0.0",
    "cross-env": "^7.0.3",
    "eslint": "^8.0.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^5.0.0",
    "husky": "^9.1.7",
    "jest": "^29.7.0",
    "prettier": "^3.0.0",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "^29.1.0",
    "ts-loader": "^9.4.3",
    "ts-node": "^10.9.1",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.1.3"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "roots": [
      "./test"
    ],
    "testRegex": ".*\\.(spec|test)\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}



prometheus.yml:
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'nestjs-metrics'
    metrics_path: '/metrics'
    static_configs:
      - targets: ['host.docker.internal:3002']
  
  - job_name: 'rabbitmq'
    static_configs:
      - targets: ['rabbitmq-exporter:9419']